<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LoL Spell Tracker</title>
  <link rel="icon" href="./images/Flash.png" type="image/png" />
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script src="./modules/SpellManager.js"></script>
  <script src="./modules/TimerManager.js"></script>
  <script src="./modules/AudioManager.js"></script>
  <script src="./modules/ConfigManager.js"></script>
  <script src="./modules/LocalizationManager.js"></script>
  <style>
    :root {
      --bg-primary: #0a0a0a;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #2a2a2a;
      --bg-card: #1e1e1e;
      --bg-card-hover: #2a2a2a;
      --bg-card-selected: #2d2d44;
      --accent-primary: #bb86fc;
      --accent-secondary: #03dac6;
      --text-primary: #ffffff;
      --text-secondary: #e0e0e0;
      --text-muted: #aaa;
      --border: #333;
      --border-focus: #bb86fc;
      --error: #ff5252;
      --success: #4caf50;
      --warning: #ff9800;
      --shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
      --shadow-hover: 0 6px 16px rgba(187, 134, 252, 0.3);
      --radius: 8px;
      --radius-large: 14px;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      
      /* Timer specific colors */
      --time-color: #cf6679;
      --time-highlight: #ffffff;
      --ready-border: #3f8efc;
      --active-border: #ffeb3b;
      --warning-border: #e53935;
      --complete-border: #4caf50;
      --shadow-active: 0 0 12px rgba(255, 235, 59, 0.6);
      --reset-btn-bg: #e53935;
      --reset-btn-text: #ffffff;
      --reset-flash-border: #3f8efc;
      --btn-shortcut-bg: #3c3c3c;
      --btn-shortcut-border: #555;
      --btn-shortcut-text: #ffffff;
      --btn-shortcut-hover: #666;
      --notif-bg: rgba(0, 0, 0, 0.7);
      --feedback-color: #ffeb3b;
      --dropdown-bg: #2a2a2a;
      --dropdown-border: #555;
      --secondary-reset-bg: #3f8efc;
      --secondary-reset-hover: #66b0ff;
      --action-btn-bg: rgba(255, 255, 255, 0.05);
      --action-btn-hover: rgba(255, 255, 255, 0.1);
      --action-btn-text: #aaa;
      --action-btn-text-hover: #fff;
      --switch-bg: #3f8efc;
    }

    body.light-theme {
      --bg-primary: #f5f5f5;
      --bg-secondary: #ffffff;
      --bg-tertiary: #e0e0e0;
      --bg-card: #ffffff;
      --bg-card-hover: #f0f0f0;
      --bg-card-selected: #e3f2fd;
      --accent-primary: #6200ea;
      --accent-secondary: #00bcd4;
      --text-primary: #212121;
      --text-secondary: #424242;
      --text-muted: #757575;
      --border: #e0e0e0;
      --border-focus: #6200ea;
      --shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      --shadow-hover: 0 6px 16px rgba(98, 0, 234, 0.2);
      background: var(--bg-primary);
      --time-color: #d81b60;
      --time-highlight: #212121;
      --ready-border: #2196f3;
      --active-border: #ff9800;
      --warning-border: #f44336;
      --complete-border: #4caf50;
      --shadow-active: 0 0 12px rgba(255, 152, 0, 0.4);
      --reset-btn-bg: #f44336;
      --btn-shortcut-bg: #f5f5f5;
      --btn-shortcut-border: #bdbdbd;
      --btn-shortcut-text: #424242;
      --btn-shortcut-hover: #e0e0e0;
      --notif-bg: rgba(255, 255, 255, 0.9);
      --feedback-color: #ff9800;
      --dropdown-bg: #ffffff;
      --dropdown-border: #bdbdbd;
      --secondary-reset-bg: #2196f3;
      --secondary-reset-hover: #1976d2;
      --action-btn-bg: rgba(0, 0, 0, 0.05);
      --action-btn-hover: rgba(0, 0, 0, 0.1);
      --action-btn-text: #757575;
      --action-btn-text-hover: #212121;
    }

    body.light-theme .sync-panel input {
      background: #f5f5f5;
      color: #212121;
      border-color: #bdbdbd;
    }

    body.light-theme .sync-panel button {
      background: #e1bee7;
      color: #4a148c;
      border-color: #e1bee7;
    }

    body.light-theme .sync-panel button#pasteBtn {
      background: #bbdefb;
      color: #0d47a1;
      border-color: #bbdefb;
    }

    body.light-theme #players-bar {
      background: rgba(33, 150, 243, 0.15);
      border-color: rgba(33, 150, 243, 0.3);
      color: #424242;
    }

    body.light-theme .sync-panel .user-nick {
      color: #424242;
      opacity: 1;
    }

    * { 
      box-sizing: border-box;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    body {
      font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, var(--bg-primary) 0%, #1a1a2e 100%);
      color: var(--text-secondary);
      margin: 0;
      padding: 20px;
      text-align: center;
      gap: 16px;
      overflow-x: hidden;
    }

    body.diana-mode {
      background: linear-gradient(135deg, rgba(10, 10, 10, 0.8) 0%, rgba(26, 26, 46, 0.8) 100%), url('./Champions_assets/Diana_0.jpg');
      background-size: cover;
      background-position: center;
      background-attachment: fixed;
    }

    .controls-top {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 24px;
      margin-bottom: 10px;
      width: 100%;
      max-width: 380px;
    }

    .switch-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 20px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #555;
      transition: 0.3s;
      border-radius: 20px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    input:checked + .slider { background-color: var(--switch-bg); }
    input:checked + .slider:before { transform: translateX(22px); }

    h1 {
      text-align: center;
      font-size: 1.5rem;
      color: var(--accent);
      margin: 10px 0 20px;
      width: 100%;
      max-width: 380px;
    }

    #players-bar {
      width: 100%;
      max-width: 380px;
      font-size: 0.8rem;
      color: #aaa;
      text-align: center;
      margin: -8px 0 12px 0;
      padding: 6px 12px;
      border-radius: 6px;
      background: rgba(95, 142, 252, 0.1);
      border: 1px solid rgba(95, 142, 252, 0.2);
      white-space: normal;
      min-height: 1.2em;
      line-height: 1.4;
    }

    .toggle-row {
      width: 100%;
      max-width: 380px;
      display: flex;
      justify-content: flex-end;
      margin-bottom: 0px;
    }

    .toggle-spells-btn {
      font-size: 0.85rem;
      color: #aaa;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #444;
      border-radius: 6px;
      padding: 4px 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      transition: all 0.2s ease;
      transform: translateX(-24px);
    }

    .toggle-spells-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--accent);
      border-color: var(--accent);
    }

    .timer-row {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      max-width: 380px;
      margin-bottom: 6px;
      position: relative;
    }

    .reset-btn {
      width: 28px;
      height: 28px;
      background: var(--reset-btn-bg);
      color: var(--reset-btn-text);
      border: none;
      border-radius: 6px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }

    .timer-row.active .reset-btn {
      opacity: 1;
      visibility: visible;
    }

    .reset-btn:hover {
      background: #ff5252;
      transform: scale(1.1);
    }

    .role-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #333;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: transform 0.2s;
    }

    .role-icon img {
      width: 28px;
      height: 28px;
    }

    .timer-row:hover .role-icon {
      transform: scale(1.1);
    }

    .timer-box {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--bg-secondary);
      border: 2px solid var(--border);
      border-radius: 8px;
      padding: 6px 10px;
      width: calc(100% - 150px);
      min-width: 200px;
      box-shadow: var(--shadow);
      gap: 10px;
      cursor: pointer;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
      position: relative;
      overflow: hidden;
      height: 44px;
    }

    .timer-box:hover:not(.active) {
      border-color: var(--ready-border);
      box-shadow: var(--shadow-hover);
    }

    .timer-box.active {
      border-color: var(--active-border);
      animation: pulse-border 1.5s infinite, pop-in 0.3s ease-out;
      box-shadow: var(--shadow-active);
      background: rgba(255, 235, 59, 0.1);
    }

    .timer-box.completed {
      border-color: var(--complete-border) !important;
      box-shadow: 0 0 12px rgba(76, 175, 80, 0.6) !important;
      background: rgba(76, 175, 80, 0.1);
      animation: none;
    }

    @keyframes pulse-border {
      0% { border-color: var(--active-border); }
      50% { border-color: #ffd54f; }
      100% { border-color: var(--active-border); }
    }

    @keyframes pop-in {
      0% { transform: scale(0.9); opacity: 0.7; }
      70% { transform: scale(1.05); }
      100% { transform: scale(1); opacity: 1; }
    }

    .role-name {
      font-weight: bold;
      color: var(--text-secondary);
      font-size: 0.85rem;
      min-width: 50px;
      text-align: left;
    }

    .time-shortcut {
      opacity: 0;
      visibility: hidden;
      font-family: 'Courier New', monospace;
      font-size: 0.75rem;
      font-weight: bold;
      color: var(--btn-shortcut-text);
      background: var(--btn-shortcut-bg);
      border: 1px solid var(--btn-shortcut-border);
      border-radius: 4px;
      width: 28px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .timer-box.active .time-shortcut {
      opacity: 1;
      visibility: visible;
    }
    
    .timer-box.buttons-hidden .time-shortcut {
      opacity: 0;
      visibility: hidden;
    }

    .time-shortcut:hover {
      background: var(--btn-shortcut-hover);
    }
    
    .time-shortcut:active {
      transform: scale(0.9);
      background: var(--accent-primary);
    }

    .time {
      width: 50px;
      text-align: center;
      font-family: 'Courier New', monospace;
      font-size: 1.1rem;
      font-weight: bold;
      color: var(--time-color);
      transition: color 0.3s ease;
    }

    .timer-box.active .time {
      color: var(--active-border);
    }

    .timer-box.active .time.warning {
      color: var(--warning-border) !important;
    }

    .time.highlight {
      color: var(--time-highlight);
    }

    /* TEMPORIZADOR SECUNDARIO */
    .static-timer {
      width: 68px;
      height: 44px;
      font-family: 'Courier New', monospace;
      font-size: 1.1rem;
      font-weight: bold;
      color: #ffffff;
      background: var(--bg-secondary) center/cover no-repeat;
      border: 2px solid var(--border);
      border-radius: 8px;
      flex-shrink: 0;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      position: relative;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      padding-bottom: 4px;
      line-height: 1;
    }

    .static-timer::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(0deg, rgba(0,0,0,0.7), rgba(0,0,0,0.5));
      border-radius: 6px;
      pointer-events: none;
    }

    .static-timer span {
      position: relative;
      z-index: 1;
      text-shadow: 0 1px 2px rgba(0,0,0,0.9);
    }

    .static-timer:hover {
      border-color: var(--ready-border);
      box-shadow: var(--shadow-hover);
    }

    .static-timer.active {
      border-color: var(--active-border);
      animation: pulse-border 1.5s infinite, pop-in 0.3s ease-out;
      box-shadow: var(--shadow-active);
      background-color: rgba(255, 235, 59, 0.15);
    }

    .static-timer.warning {
      border-color: var(--warning-border);
      box-shadow: 0 0 12px rgba(229, 57, 53, 0.6);
      color: var(--warning-border);
    }

    /* Smite especial - sin filtro oscuro, solo referencia visual */
    .static-timer.smite-reference::before {
      display: none;
    }

    .static-timer.smite-reference {
      cursor: default;
      opacity: 0.8;
    }

    .static-timer.smite-reference:hover {
      border-color: var(--border);
      box-shadow: none;
    }

    /* Desplegable - con animación suave */
    .spell-select {
      width: 68px;
      height: 44px;
      padding: 6px 8px;
      background: var(--dropdown-bg);
      color: var(--text);
      border: 1px solid var(--dropdown-border);
      border-radius: 8px;
      font-size: 0.8rem;
      font-family: inherit;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%226%22%3E%3Cpath%20d%3D%22M1%201l4%204%204-4%22%20stroke%3D%22%23888%22%20fill%3D%22none%22%20stroke-width%3D%221.5%22/%3E%3C%2Fsvg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 10px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      flex-shrink: 0;
      order: 3;
    }

    .spell-select:hover {
      border-color: var(--accent);
      background-color: #3a3a3a;
    }

    .spell-select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 8px rgba(187, 134, 252, 0.4);
    }

    /* Overlay de reinicio */
    .reset-message {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      font-weight: bold;
      border-radius: 8px;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
      z-index: 10;
    }

    .reset-message.show {
      opacity: 1;
    }

    .reset-flash {
      border-color: var(--reset-flash-border) !important;
      box-shadow: 0 0 10px rgba(63, 142, 252, 0.6) !important;
    }

    /* Feedback visual */
    .time-notification {
      position: absolute;
      top: -28px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--notif-bg);
      color: white;
      font-size: 0.8rem;
      font-family: 'Courier New', monospace;
      padding: 3px 8px;
      border-radius: 4px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s;
      z-index: 20;
    }

    .time-notification.show {
      opacity: 1;
      visibility: visible;
    }

    .feedback {
      position: absolute;
      bottom: -22px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--feedback-color);
      color: #000;
      font-size: 0.75rem;
      font-family: 'Courier New', monospace;
      padding: 2px 8px;
      border-radius: 4px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.15s;
      z-index: 20;
    }

    .feedback.show {
      opacity: 1;
      visibility: visible;
    }

    /* Botón de reinicio secundario */
    .reset-btn-secondary {
      width: 28px;
      height: 28px;
      background: var(--secondary-reset-bg);
      color: var(--reset-btn-text);
      border: none;
      border-radius: 6px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      order: 99;
    }

    .timer-row.secondary-active .reset-btn-secondary {
      opacity: 1;
      visibility: visible;
    }

    .reset-btn-secondary:hover {
      background: var(--secondary-reset-hover);
      transform: scale(1.1);
    }

    /* Botón combinado: Start Game / Reset All */
    .main-action-btn {
      padding: 6px 16px;
      background: var(--action-btn-bg);
      color: var(--action-btn-text);
      border: 1px solid #444;
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: normal;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      margin-top: -15px;
    }

    .main-action-btn:hover {
      background: var(--action-btn-hover);
      color: var(--action-btn-text-hover);
      border-color: var(--accent);
    }

    .main-action-btn:active {
      transform: scale(0.98);
      box-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
    }

    /* Temporizador de 10 minutos (sutil) */
    .game-timer {
      font-family: 'Courier New', monospace;
      font-size: 1.1rem;
      font-weight: bold;
      color: var(--accent);
      min-width: 60px;
      text-align: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
      transform: translateY(-5px);
    }

    .game-timer.active {
      opacity: 1;
      visibility: visible;
    }

    .version-footer {
      margin-top: 8px;
      margin-bottom: 6px;
      font-size: 0.75rem;
      color: var(--text);
      text-align: center;
      opacity: 0.6;
      letter-spacing: 0.5px;
      font-family: 'Courier New', monospace;
      width: 100%;
      max-width: 380px;
      padding: 6px 0;
      border-top: 1px solid var(--border);
      transition: opacity 0.3s, color 0.3s;
    }

    .tutorial-box {
      width: 100%;
      max-width: 380px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 0.78rem;
      color: var(--text);
      line-height: 1.5;
      text-align: left;
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
    }
    .tutorial-box.show {
      max-height: 200px;
      opacity: 1;
    }
    .tutorial-toggle {
      width: 100%;
      max-width: 380px;
      background: var(--action-btn-bg);
      color: var(--action-btn-text);
      border: 1px solid #444;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .tutorial-toggle:hover {
      background: var(--action-btn-hover);
      color: var(--action-btn-text-hover);
      border-color: var(--accent);
    }
    .tutorial-box strong {
      color: var(--accent);
    }
    .key-hint {
      display: inline-block;
      background: var(--btn-shortcut-bg);
      color: var(--btn-shortcut-text);
      border: 1px solid var(--btn-shortcut-border);
      border-radius: 4px;
      padding: 2px 6px;
      font-family: 'Courier New', monospace;
      font-size: 0.8rem;
      margin: 0 2px;
    }

    .sync-panel {
      width: 100%;
      max-width: 380px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 14px 16px;
      font-size: 0.85rem;
      margin-bottom: 2px;
      color: var(--text);
    }
    .sync-panel h3 {
      margin: 0 0 10px 0;
      font-size: 1.05rem;
      color: var(--accent);
    }
    .sync-panel .input-group {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 6px 0;
    }
    .sync-panel .status {
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-align: left;
    }
    .sync-panel .user-nick {
      font-size: 0.85rem;
      color: #bbb;
      opacity: 0.9;
    }
    .sync-panel input {
      flex: 1;
      padding: 8px 10px;
      border: 1px solid var(--btn-shortcut-border);
      border-radius: 6px;
      background: #333;
      color: white;
      font-family: monospace;
      font-size: 0.95rem;
      text-transform: uppercase;
    }
    .sync-panel button {
      padding: 8px 6px;
      background: var(--accent-primary);
      color: #000;
      border: 1px solid var(--accent-primary);
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      font-size: 0.8rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: all 0.2s ease;
    }
    .sync-panel button#pasteBtn {
      background: var(--secondary-reset-bg);
      border-color: var(--secondary-reset-bg);
      color: white;
    }
    .sync-panel button#pasteBtn:hover {
      background: var(--secondary-reset-hover);
      border-color: var(--secondary-reset-hover);
    }
    .sync-panel button:hover {
      opacity: 0.9;
      transform: translateY(-1px);
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
    }
    .sync-panel button:active {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
  </style>
  
  <!-- Pre-carga de recursos -->
  <link rel="preload" href="./images/Bottom_icon.png" as="image">
  <link rel="preload" href="./images/Diana_0.jpg" as="image">
  <link rel="preload" href="./images/Diana.png" as="image">
  <link rel="preload" href="./images/Flash.png" as="image">
  <link rel="preload" href="./images/Jungle_icon.png" as="image">
  <link rel="preload" href="./images/Middle_icon.png" as="image">
  <link rel="preload" href="./images/SummonerBarrier.png" as="image">
  <link rel="preload" href="./images/SummonerBoost.png" as="image">
  <link rel="preload" href="./images/SummonerDot.png" as="image">
  <link rel="preload" href="./images/SummonerExhaust.png" as="image">
  <link rel="preload" href="./images/SummonerHaste.png" as="image">
  <link rel="preload" href="./images/SummonerHeal.png" as="image">
  <link rel="preload" href="./images/SummonerSmite.png" as="image">
  <link rel="preload" href="./images/SummonerTeleport.png" as="image">
  <link rel="preload" href="./images/Support_icon.png" as="image">
  <link rel="preload" href="./images/Top_icon.png" as="image">
</head>
<body>
  <div class="controls-top">
    <div class="switch-container">
      <span>🌙</span>
      <label class="switch">
        <input type="checkbox" id="themeSwitch" />
        <span class="slider"></span>
      </label>
      <span>☀️</span>
    </div>
    <div class="switch-container">
      <span>🇬🇧</span>
      <label class="switch">
        <input type="checkbox" id="langSwitch" />
        <span class="slider"></span>
      </label>
      <span>🇪🇸</span>
    </div>
    <div class="switch-container">
      <span>🔇</span>
      <label class="switch">
        <input type="checkbox" id="soundSwitch" checked />
        <span class="slider"></span>
      </label>
      <span>🔊</span>
    </div>
  </div>

  <h1 id="appTitle">LoL Spell Tracker</h1>
  
  <div id="players-bar">
    <span id="players-list">Waiting for players...</span>
  </div>

  <div class="sync-panel" id="syncPanel">
    <!-- Dinámico según rol -->
  </div>

  <!-- Botón show/hide en su propia fila, encima de los temporizadores -->
  <div class="toggle-row">
    <button class="toggle-spells-btn" id="toggleSpellsBtn">
      <span id="toggleArrow">➡️</span>
      <span id="toggleText">show</span>
    </button>
  </div>

  <div id="timers"></div>
  
  <div id="timer-error-msg" style="display: none; color: var(--warning); font-size: 0.8rem; margin-top: 8px; text-align: center; max-width: 380px;">
    <!-- Dinámico -->
  </div>
  <script>
    // ====================== CONFIGURACIÓN DESDE SESSIONSTORAGE ======================
    let launchConfig = {};
    try {
      launchConfig = JSON.parse(sessionStorage.getItem('lol-tracker-launch-config') || '{}');
      console.log('Loaded config:', launchConfig);
    } catch (e) {
      console.log('Error parsing launch config:', e);
    }
    
    const champions = ['Aatrox', 'Ahri', 'Akali', 'Akshan', 'Alistar', 'Ambessa', 'Amumu', 'Anivia', 'Annie', 'Aphelios', 'Ashe', 'Aurelion Sol', 'Aurora', 'Azir', 'Bard', 'Bel\'Veth', 'Blitzcrank', 'Brand', 'Braum', 'Briar', 'Caitlyn', 'Camille', 'Cassiopeia', 'Cho\'Gath', 'Corki', 'Darius', 'Diana', 'Dr. Mundo', 'Draven', 'Ekko', 'Elise', 'Evelynn', 'Ezreal', 'Fiddlesticks', 'Fiora', 'Fizz', 'Galio', 'Gangplank', 'Garen', 'Gnar', 'Gragas', 'Graves', 'Gwen', 'Hecarim', 'Heimerdinger', 'Hwei', 'Illaoi', 'Irelia', 'Ivern', 'Janna', 'Jarvan IV', 'Jax', 'Jayce', 'Jhin', 'Jinx', 'K\'Sante', 'Kai\'Sa', 'Kalista', 'Karma', 'Karthus', 'Kassadin', 'Katarina', 'Kayle', 'Kayn', 'Kennen', 'Kha\'Zix', 'Kindred', 'Kled', 'Kog\'Maw', 'LeBlanc', 'Lee Sin', 'Leona', 'Lillia', 'Lissandra', 'Lucian', 'Lulu', 'Lux', 'Malphite', 'Malzahar', 'Maokai', 'Master Yi', 'Mel', 'Milio', 'Miss Fortune', 'Mordekaiser', 'Morgana', 'Naafiri', 'Nami', 'Nasus', 'Nautilus', 'Neeko', 'Nidalee', 'Nilah', 'Nocturne', 'Nunu & Willump', 'Olaf', 'Orianna', 'Ornn', 'Pantheon', 'Poppy', 'Pyke', 'Qiyana', 'Quinn', 'Rakan', 'Rammus', 'Rek\'Sai', 'Rell', 'Renata Glasc', 'Renekton', 'Rengar', 'Riven', 'Rumble', 'Ryze', 'Samira', 'Sejuani', 'Senna', 'Seraphine', 'Sett', 'Shaco', 'Shen', 'Shyvana', 'Singed', 'Sion', 'Sivir', 'Skarner', 'Smolder', 'Sona', 'Soraka', 'Swain', 'Sylas', 'Syndra', 'Tahm Kench', 'Taliyah', 'Talon', 'Taric', 'Teemo', 'Thresh', 'Tristana', 'Trundle', 'Tryndamere', 'Twisted Fate', 'Twitch', 'Udyr', 'Urgot', 'Varus', 'Vayne', 'Veigar', 'Vel\'Koz', 'Vex', 'Vi', 'Viego', 'Viktor', 'Vladimir', 'Volibear', 'Warwick', 'Wukong', 'Xayah', 'Xerath', 'Xin Zhao', 'Yasuo', 'Yone', 'Yorick', 'Yuumi', 'Zac', 'Zed', 'Zeri', 'Ziggs', 'Zilean', 'Zoe', 'Zyra'];
    const userNickname = launchConfig.nick || champions[Math.floor(Math.random() * champions.length)];
    const userChampion = launchConfig.champion || '';
    const userColor = launchConfig.color || '#bb86fc';
    const userRole = launchConfig.role || 'join';
    const urlTheme = launchConfig.theme;
    const urlLang = launchConfig.lang;
    
    // Mostrar botón para abrir en ventana si es necesario
    if (launchConfig.shouldOpenAsWindow && launchConfig.autoJoin) {
      setTimeout(() => {
        const banner = document.createElement('div');
        banner.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          background: #2196f3;
          color: white;
          padding: 12px;
          text-align: center;
          z-index: 10000;
          font-size: 0.9rem;
        `;
        banner.innerHTML = `
          <span>🪟 Click to open in window mode: </span>
          <button onclick="openInWindow()" style="background: white; color: #2196f3; border: none; padding: 4px 12px; border-radius: 4px; margin-left: 8px; cursor: pointer; font-weight: bold;">Open Window</button>
          <button onclick="this.parentElement.remove()" style="background: transparent; color: white; border: 1px solid white; padding: 4px 8px; border-radius: 4px; margin-left: 8px; cursor: pointer;">×</button>
        `;
        document.body.appendChild(banner);
        
        window.openInWindow = () => {
          const windowSize = localStorage.getItem('window-size') || 'medium';
          const sizes = { small: [500, 700], medium: [500, 800], large: [600, 1080] };
          const [width, height] = sizes[windowSize];
          const opciones = `width=${width},height=${height},resizable=yes,scrollbars=no,titlebar=no,toolbar=no,location=no,status=no`;
          
          const newWindow = window.open(window.location.href, `LoLFlashTracker_${Date.now()}`, opciones);
          if (newWindow) {
            window.close();
          }
        };
      }, 1000);
    }

    let isHost = userRole === 'host';
    let isSoloMode = userRole === 'solo';
    
    function getChampionFileName(championName) {
      // Special cases first
      const specialCases = {
        "Dr. Mundo": "Dr_Mundo",
        "Nunu": "Nunu_&_Willump"
      };
      
      if (specialCases[championName]) {
        return specialCases[championName];
      }
      
      // Keep straight apostrophes as they are in file names
      let fileName = championName
        .replace(/ /g, "_")   // spaces to underscores
        .replace(/\./g, "_"); // dots to underscores
      
      return fileName;
    }
    
    // Limpiar configuración después de usar
    setTimeout(() => {
      sessionStorage.removeItem('lol-tracker-launch-config');
    }, 500);

    // Utilities and constants
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function sanitizeNickname(nick) {
      if (typeof nick !== 'string') return 'Player';
      return nick.replace(/[<>"'&]/g, '').trim() || 'Player';
    }

    function validateEventData(data) {
      if (!data || typeof data !== 'object') return false;
      if (typeof data.a !== 'string') return false;
      
      switch (data.a) {
        case 'start':
        case 'reset':
        case 'startSecondary':
        case 'resetSecondary':
          return typeof data.i === 'number' && data.i >= 0 && data.i < 5;
        case 'adjust':
          return typeof data.i === 'number' && data.i >= 0 && data.i < 5 &&
                 typeof data.s === 'number' && data.s >= -300 && data.s <= 300;
        case 'changeSpell':
          return typeof data.i === 'number' && data.i >= 0 && data.i < 5 &&
                 typeof data.spell === 'string' && spellData[data.spell];
        case 'hello':
          return typeof data.nick === 'string';
        default:
          return true;
      }
    }

    const DURATIONS = TimerManager.DURATIONS;

    // ====================== GENERADOR DE ID ======================
    function generateShortId() {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let id = '';
      for (let i = 0; i < 6; i++) {
        id += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return id;
    }

    // ====================== TRADUCCIONES ======================
    const translations = LocalizationManager.translations;

    let lang = urlLang || ConfigManager.getLanguage();
    LocalizationManager.init(lang);

    // Cargar tema desde configuración
    const themeToUse = ConfigManager.getTheme(urlTheme);
    ConfigManager.applyTheme(themeToUse);

    // Configuración inicial (se ejecutará en DOMContentLoaded)

    // ====================== VARIABLES GLOBALES ======================
    let shortId = generateShortId();
    let peer = null;
    let myPeerId = null;
    let connections = [];
    let myConnection = null;
    let heartbeatInterval = null;
    let hostLostTimeout = null;
    let playersBeforeDisconnect = new Map();
    let peerConnections = new Map();
    // HOST: Variables de control
    let myBackupId = null;
    let secondaryHostId = null;
    let secondaryHostBackupId = null;
    let hostBackupId = null;
    let joinOrder = []; // Para trackear orden de entrada
    let playerBackupIds = new Map();
    
    // ====================== INICIALIZACIÓN HOST ======================
    function initializeHost() {
      // 1.2. Borrar información almacenada
      myBackupId = null;
      secondaryHostId = null;
      secondaryHostBackupId = null;
      hostBackupId = null;
      joinOrder = [];
      
      // 1.3. Generar backupID para el host
      myBackupId = generateShortId();
      
      // 1.4. Borrar lista de jugadores
      connectedPlayers.clear();
      
      // 1.5. Actualizar con información propia
      connectedPlayers.set(myPeerId, { 
        nick: sanitizeNickname(userNickname), 
        champion: userChampion, 
        color: userColor, 
        lastPong: Date.now(), 
        isSelf: true 
      });
      
      updatePlayersBar();
      
      // 1.6. Queda a la espera de conexiones entrantes
      if (peer && peer.open) {
        startHostMonitoring();
      }
      
      // 1.7. Mostrar mensaje
      // La promoción a host se maneja en setupSyncPanel()
    }
    
    // ====================== RECONEXIÓN CON REINTENTOS ======================
    let isReconnecting = false;
    
    function attemptReconnectionWithRetries() {
      if (isReconnecting) {
        // Ya hay una reconexión en curso
        return;
      }
      
      isReconnecting = true;
      let attempt = 1;
      const maxAttempts = 3;
      
      function tryReconnect() {
        if (attempt > maxAttempts) {
          // 6.3.6. Mensaje final de conexión perdida
          isReconnecting = false;
          // Actualizar estado de conexión perdida
          document.getElementById('clientStatus').innerHTML = `
            <span class="error">❌ ${lang === 'es' ? 'Conexión perdida' : 'Connection lost'}</span>
            <span class="user-nick">${sanitizeNickname(userNickname)}</span>
          `;
          return;
        }
        
        // 6.3. Mostrar mensaje de reconexión
        const message = attempt === 1 ? 
          (lang === 'es' ? '🔄 Reconectando...' : '🔄 Reconnecting...') :
          (lang === 'es' ? `🔄 (${attempt})Reconectando...` : `🔄 (${attempt})Reconnecting...`);
        
        // Actualizar estado de reconexión
        document.getElementById('clientStatus').innerHTML = `
          <span class="info">${message}</span>
          <span class="user-nick">${sanitizeNickname(userNickname)}</span>
        `;
        
        if (hostBackupId) {
          const hostPeerId = `${hostBackupId}_host`;

          const testConnection = peer.connect(hostPeerId);
          
          const timeout = setTimeout(() => {

            testConnection.close();
            attempt++;
            setTimeout(tryReconnect, 100);
          }, 10000);
          
          testConnection.on('open', () => {

            isReconnecting = false;
            clearTimeout(timeout);
            
            // CRITICAL: Establecer myConnection correctamente
            if (myConnection) {
              myConnection.removeAllListeners();
            }
            myConnection = testConnection;
            
            // CRITICAL: Configurar event listener de close para detectar desconexiones
            myConnection.on('close', () => {
              if (heartbeatInterval) clearInterval(heartbeatInterval);
              
              if (secondaryHostId === myPeerId) {
                isHost = true;
                shortId = hostBackupId;
                hostNickname = sanitizeNickname(userNickname);
                initializeHost();
                setupSyncPanel();
                initPeer();
              } else {
                attemptReconnectionWithRetries();
              }
            });
            
            // 6.4. Conecta exitosamente - 6.5. Repetir punto 2 completo
            setTimeout(() => {
              // 2.1. Enviar información al host
              myConnection.send({ a: 'playerInfo', nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor, from: myPeerId });
            
              // Iniciar heartbeat
              heartbeatInterval = setInterval(() => {
                if (myConnection && myConnection.open) {
                  myConnection.send({ a: 'heartbeat', from: myPeerId });
                }
              }, 2000);
            }, 50);
            
            myConnection.on('data', (data) => {
              if (!validateEventData(data)) return;
              
              if (data.a === 'heartbeat') {
                // Responder al heartbeat del HOST
                myConnection.send({ a: 'heartbeatAck', from: myPeerId });
              } else if (data.a === 'connectionSuccess') {
                // 2.2-2.5. Procesar respuesta del host como en punto 2
                handleSync(data);
                
                // Actualizar estado de reconexión exitosa
                const hostName = data.playersList[0][1].nick;
                const trans = LocalizationManager.getTranslations();
                document.getElementById('clientStatus').innerHTML = `
                  <span class="success">✓ ${lang === 'es' ? 'Reconectado a' : 'Reconnected to'} <strong>${escapeHtml(hostName)}</strong></span>
                  <span class="user-nick">${sanitizeNickname(userNickname)}</span>
                `;
              } else {
                handleSync(data);
              }
            });
            
            myConnection.on('close', () => {
              if (heartbeatInterval) clearInterval(heartbeatInterval);
              attemptReconnectionWithRetries();
            });
          });
          
          testConnection.on('error', (err) => {

            clearTimeout(timeout);
            attempt++;
            setTimeout(tryReconnect, 100);
          });
        } else {

          attempt++;
          setTimeout(tryReconnect, 100);
        }
      }
      
      tryReconnect();
    }
    // joinOrder removed - derived from connectedPlayers
    let hostNickname = null;
    let hadHostConnection = false;

    const connectedPlayers = new Map();
    const pendingPings = new Map();

    let pingInterval = null;
    let cleanupInterval = null;

    // Spells disponibles
    const spellData = SpellManager.spellData;

    const roles = SpellManager.roles;
    const icons = SpellManager.icons;
    const defaultSpells = SpellManager.defaultSpells;
    const keyMap = SpellManager.keyMap;
    let timerBoxes = [];
    let staticTimers = [];
    let spellSelects = [];
    let autoHideTimeout = null;
    let gameTimerInterval = null;
    let isGameStarted = false;
    let isTeleportUnleashed = false;

    // Declarar gameTimerEl y mainActionBtn (asignarán después)
    let gameTimerEl, mainActionBtn;

    const formatTime = TimerManager.formatTime.bind(TimerManager);


    // ====================== FUNCIÓN PARA MOSTRAR BOTONES ======================
    function showButtonsWithTimeout(box) {
      box.classList.remove('buttons-hidden');
      if (box.hoverTimeout) {
        clearTimeout(box.hoverTimeout);
      }
      box.hoverTimeout = setTimeout(() => {
        if (box.classList.contains('active')) {
          box.classList.add('buttons-hidden');
        }
      }, 10000);
    }

    // ====================== FUNCIONES PRINCIPALES ======================
    function startTimer(box, shouldSync = true) {
      TimerManager.startTimer(box, shouldSync, {
        sendEvent, playPingSound, checkTimerErrors
      });
    }

    function resetTimer(box, shouldSync = true) {
      TimerManager.resetTimer(box, shouldSync, { sendEvent });
    }

    function adjustTime(box, seconds, shouldSync = true) {
      TimerManager.adjustTime(box, seconds, shouldSync, { sendEvent });
    }

    // ====================== TEMPORIZADORES SECUNDARIOS ======================
    const startStaticTimer = TimerManager.startStaticTimer.bind(TimerManager);

    function resetStaticTimer(el, select) {
      TimerManager.resetStaticTimer(el, select, isTeleportUnleashed);
    }

    const updateStaticTimerStyle = TimerManager.updateStaticTimerStyle.bind(TimerManager);

    let errorTimeout = null;
    
    function checkTimerErrors(startTimeMinutes, startTimeSeconds) {
      TimerManager.checkTimerErrors(startTimeMinutes, startTimeSeconds, lang, errorTimeout, (newTimeout) => {
        errorTimeout = newTimeout;
      });
    }

    // ====================== TOGGLE + AUTO-HIDE ======================
    function toggleSpells() {
      const btn = document.getElementById('toggleSpellsBtn');
      const arrow = document.getElementById('toggleArrow');
      const text = document.getElementById('toggleText');
      const isShowing = arrow.textContent.trim() === '⬅️';

      if (autoHideTimeout) {
        clearTimeout(autoHideTimeout);
        autoHideTimeout = null;
      }

      if (isShowing) {
        spellSelects.forEach(el => el.style.display = 'none');
        staticTimers.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('.reset-btn-secondary').forEach(btn => btn.style.display = 'flex');
        document.querySelectorAll('.timer-box').forEach(box => box.style.transform = '');
        document.querySelectorAll('.role-icon').forEach((icon, i) => {
          icon.style.transform = '';
          const img = icon.querySelector('img');
          img.src = icons[i];
        });
        arrow.textContent = '➡️';
        text.textContent = 'show';
      } else {
        spellSelects.forEach(el => el.style.display = 'block');
        staticTimers.forEach(el => el.style.display = 'none');
        document.querySelectorAll('.reset-btn-secondary').forEach(btn => btn.style.display = 'none');
        document.querySelectorAll('.timer-box').forEach(box => box.style.transform = 'translateX(-15px)');
        document.querySelectorAll('.role-icon').forEach((icon, i) => {
          icon.style.transform = 'translateX(-15px)';
          const img = icon.querySelector('img');
          const spell = spellSelects[i].value;
          img.src = spellData[spell].icon;
        });
        arrow.textContent = '⬅️';
        text.textContent = 'hide';

        autoHideTimeout = setTimeout(() => {
          spellSelects.forEach(el => el.style.display = 'none');
          staticTimers.forEach(el => el.style.display = 'flex');
          document.querySelectorAll('.reset-btn-secondary').forEach(btn => btn.style.display = 'flex');
          document.querySelectorAll('.timer-box').forEach(box => box.style.transform = '');
          document.querySelectorAll('.role-icon').forEach((icon, i) => {
            icon.style.transform = '';
            const img = icon.querySelector('img');
            img.src = icons[i];
          });
          arrow.textContent = '➡️';
          text.textContent = 'show';
          autoHideTimeout = null;
        }, 30000);
      }
    }

    // ====================== GAME TIMER (10 minutos) ======================
    function startGameTimer() {
      if (gameTimerInterval) {
        clearInterval(gameTimerInterval);
        gameTimerInterval = null;
      }

      let totalSeconds = DURATIONS.GAME;
      gameTimerEl.textContent = formatTime(totalSeconds);
      gameTimerEl.classList.add('active');

      gameTimerInterval = setInterval(() => {
        totalSeconds--;
        gameTimerEl.textContent = formatTime(totalSeconds);

        if (totalSeconds <= 0) {
          clearInterval(gameTimerInterval);
          gameTimerInterval = null;
          gameTimerEl.textContent = 'Unleashed Teleport!';
          updateTeleportDuration(240);
          sendEvent({ a: 'unleashedTeleport' });
        }
      }, 1000);

      sendEvent({ a: 'startGame' });
      isGameStarted = true;
    }

    function resetAll(shouldSync = true) {
      TimerManager.resetAll(timerBoxes, staticTimers, spellSelects, gameTimerEl, mainActionBtn, shouldSync, {
        sendEvent, clearErrorTimeout: () => {
          const errorMsg = document.getElementById('timer-error-msg');
          errorMsg.style.display = 'none';
          if (errorTimeout) {
            clearTimeout(errorTimeout);
            errorTimeout = null;
          }
        }
      });
      
      if (gameTimerInterval) {
        clearInterval(gameTimerInterval);
        gameTimerInterval = null;
      }
      
      isTeleportUnleashed = false;
      updateTeleportDuration(300);
      isGameStarted = false;
    }

    // ====================== SONIDO ======================
    function playPingSound() {
      AudioManager.playPingSound(soundSwitch);
    }

    function soundEnabled() {
      return AudioManager.soundEnabled(soundSwitch);
    }

    // ====================== CONFIGURACIÓN ======================
    const soundSwitch = document.getElementById('soundSwitch');
    
    // Configurar event listeners con ConfigManager
    ConfigManager.setupEventListeners({
      onLanguageChange: (newLang) => {
        lang = newLang;
        updateTexts();
        
        const errorMsg = document.getElementById('timer-error-msg');
        if (errorMsg.style.display === 'block') {
          errorMsg.textContent = lang === 'es' ? '¿Temporizadores incorrectos? Comprueba la hora del sistema.' : 'Wrong timers? Check system time.';
        }
      },
      onThemeChange: (newTheme) => {
        // Tema ya aplicado por ConfigManager
      }
    });

    // ====================== ACTUALIZAR TEXTOS ======================
    function updateTexts() {
      LocalizationManager.setLanguage(lang);
      const trans = LocalizationManager.updateTexts({ updatePlayersBar });

      if (isHost) {
        const myShortId = document.getElementById('myShortId');
        if (myShortId) myShortId.value = shortId;

        const hostStatus = document.getElementById('hostStatus');
        if (hostStatus) {
          hostStatus.innerHTML = `
            <span class="status success">✅ ${trans.host}</span>
            <span class="user-nick">${userNickname}</span>
          `;
        }

        const copyBtn = document.querySelector('#syncPanel button');
        if (copyBtn) copyBtn.textContent = trans.copy;
      } else {
        const pasteBtn = document.getElementById('pasteBtn');
        const joinBtn = document.querySelector('#syncPanel button[onclick="connectToHost()"]');
        if (pasteBtn) pasteBtn.textContent = trans.paste;
        if (joinBtn) joinBtn.textContent = trans.join;
      }

      document.getElementById('tutorialBox').innerHTML = `
        <div><strong>${trans.tutorialTitle}</strong></div>
        <div><span class="key-hint">1-5</span> ${trans.keyStart}</div>
        <div><span class="key-hint">Alt+1</span> ${trans.keyAlt}</div>
        <div><span class="key-hint">Shift+1</span> ${trans.keyShift}</div>
        <div><span class="key-hint">🖱️</span> ${trans.keyClick}</div>
        <div><span class="key-hint">×</span> ${trans.keyReset}</div>
        <div style="font-size:0.7rem; margin-top:8px; color:#aaa;">
          👤 <strong>${userNickname}</strong> (${userRole === 'host' ? (lang === 'es' ? 'Anfitrión' : 'Host') : (lang === 'es' ? 'Invitado' : 'Guest')})
        </div>
      `;

      document.querySelectorAll('.role-name').forEach((el, i) => {
        const role = ['Top', 'Jungle', 'Middle', 'Bottom', 'Support'][i];
        el.textContent = lang === 'es' ? {
          'Top': 'Superior',
          'Jungle': 'Jungla',
          'Middle': 'Medio',
          'Bottom': 'Inferior',
          'Support': 'Soporte'
        }[role] : role;
      });

      document.querySelectorAll('.reset-message').forEach(el => {
        el.textContent = trans.reset;
      });
    }

    // ====================== CONFIGURAR PANEL DE SINCRONIZACIÓN ======================
    function setupSyncPanel() {
      const panel = document.getElementById('syncPanel');
      const playersBar = document.getElementById('players-bar');
      const trans = LocalizationManager.getTranslations();

      if (isSoloMode) {
        panel.style.display = 'none';
        playersBar.style.display = 'none';
        return;
      }

      if (isHost) {
        let championImg = '';
        if (userChampion) {
          const fileName = getChampionFileName(userChampion);
          championImg = `<img src="./Champions_assets/${fileName}.png" style="width: 20px; height: 20px; border-radius: 3px; margin-right: 6px; vertical-align: middle;" onerror="this.style.display='none'">`;
        }
        
        panel.innerHTML = `
          <h3 style="display: flex; justify-content: space-between; align-items: center;">
            <span>🔑 ${trans.hostId}</span>
            <span id="playerCount" style="font-size: 0.8rem; color: #aaa; display: none;"></span>
          </h3>
          <div class="input-group">
            <input type="text" id="myShortId" readonly value="${trans.generating}" style="font-size: 1rem; text-align: center;">
            <button onclick="copyId()">${trans.copy}</button>
            <button id="inviteBtn" onclick="generateInviteLink()" style="background: #4ecdc4; margin-left: 8px; transition: all 0.3s ease;" onmouseenter="this.style.background='#45b7d1'; this.style.transform='scale(1.05)';" onmouseleave="this.style.background='#4ecdc4'; this.style.transform='scale(1)';" onmousedown="this.style.transform='scale(0.95)';" onmouseup="this.style.transform='scale(1.05)';">📤 Invite</button>
          </div>
          <div class="status" id="hostStatus">
            <span>🟢 ${trans.waiting}</span>
            <span class="user-nick">${championImg}${userNickname}</span>
          </div>
        `;
      } else {
        panel.innerHTML = `
          <h3 style="display: flex; justify-content: space-between; align-items: center;">
            <span>🔑 ${trans.hostId}</span>
            <span id="playerCount" style="font-size: 0.8rem; color: #aaa; display: none;"></span>
          </h3>
          <div class="input-group">
            <input type="text" id="hostIdInput" placeholder="${trans.hostId}" maxlength="6">
            <button id="pasteBtn" onclick="pasteId()">${trans.paste}</button>
            <button onclick="connectToHost()">${trans.join}</button>
          </div>
          <div class="status" id="clientStatus">
            <span></span>
            <span class="user-nick">${userNickname}</span>
          </div>
        `;
      }
      updatePlayersBar();
    }

    // ====================== PEGAR Y COPIAR ID ======================
    async function pasteId() {
      const trans = LocalizationManager.getTranslations();
      try {
        const text = await navigator.clipboard.readText();
        const clean = text.trim().toUpperCase();
        if (/^[A-HJ-NP-Z2-9]{6}$/.test(clean)) {
          document.getElementById('hostIdInput').value = clean;
        } else {
          document.getElementById('clientStatus').innerHTML = `
            <span class="error">❌ ${trans.invalidId}</span>
            <span class="user-nick">${userNickname}</span>
          `;
        }
      } catch (err) {
        document.getElementById('clientStatus').innerHTML = `
          <span class="error">❌ ${trans.error}: clipboard</span>
          <span class="user-nick">${userNickname}</span>
        `;
      }
    }

    function copyId() {
      const trans = LocalizationManager.getTranslations();
      const input = document.getElementById('myShortId');
      input.select();
      document.execCommand('copy');
      input.value = trans.copy;
      setTimeout(() => { input.value = shortId; }, 1000);
    }
    
    function generateInviteLink() {
      if (!shortId || shortId === 'Generating...') {
        showToast('Wait for room ID to generate', 'error', 2000);
        return;
      }
      
      const baseUrl = window.location.origin + window.location.pathname.replace(/\/[^/]*$/, '');
      const inviteUrl = `${baseUrl}/?invite=${shortId}`;
      
      navigator.clipboard.writeText(inviteUrl).then(() => {
        const btn = document.getElementById('inviteBtn');
        const originalText = btn.innerHTML;
        btn.innerHTML = '✓ Copied!';
        btn.style.background = '#00b894';
        
        setTimeout(() => {
          btn.innerHTML = originalText;
          btn.style.background = '#4ecdc4';
        }, 2000);
        
        showToast('Invite link copied to clipboard!', 'success', 2000);
      }).catch(() => {
        // Fallback para navegadores sin clipboard API
        const tempInput = document.createElement('input');
        tempInput.value = inviteUrl;
        document.body.appendChild(tempInput);
        tempInput.select();
        document.execCommand('copy');
        document.body.removeChild(tempInput);
        
        showToast('Invite link copied!', 'success', 2000);
      });
    }
    


    // ====================== INICIALIZAR PEER ======================
    function initPeer() {
      if (peer) {
        peer.destroy();
        connections = [];
        myConnection = null;
        clearInterval(pingInterval);
        clearInterval(cleanupInterval);
      }

      const config = {
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
            { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' }
          ]
        }
      };

      const peerId = isHost ? `${shortId}_host` : `${shortId}_client_${Math.random().toString(36).substr(2, 6)}`;
      peer = new Peer(peerId, config);

      peer.on('open', (id) => {
        myPeerId = id;
        
        if (isHost) {
          // No limpiar si ya hay conexiones P2P
          if (connections.length === 0) {
            connectedPlayers.clear();
          }
        }
        connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });

        if (isHost) {
          const myShortIdInput = document.getElementById('myShortId');
          myShortIdInput.value = shortId;
          
          // Mostrar mensaje temporal si hay conexiones existentes
          if (connections.length > 0) {
            document.getElementById('hostStatus').innerHTML = `
              <span class="status success">✅ Reconectado jugadores</span>
              <span class="user-nick">${sanitizeNickname(userNickname)}</span>
            `;
            setTimeout(() => {
              document.getElementById('hostStatus').innerHTML = `
                <span class="status success">✅ ${LocalizationManager.getTranslations().host}</span>
                <span class="user-nick">${sanitizeNickname(userNickname)}</span>
              `;
            }, 10000);
            
            // Notificar a invitados que se reconectaron
            connections.forEach(conn => {
              if (conn.open) {
                conn.send({ a: 'hostInfo', nick: sanitizeNickname(userNickname), from: myPeerId });
              }
            });
          } else {
            document.getElementById('hostStatus').innerHTML = `
              <span class="status success">✅ ${LocalizationManager.getTranslations().host}</span>
              <span class="user-nick">${sanitizeNickname(userNickname)}</span>
            `;
          }
          

          
          startHostMonitoring();
          broadcastPlayerList();
        }
      });

      peer.on('error', (err) => {
        const trans = LocalizationManager.getTranslations();
        if (err.type === 'unavailable-id') {
          document.getElementById('hostStatus').innerHTML = `
            <span class="error">❌ ${trans.idInUse}</span>
            <span class="user-nick">${userNickname}</span>
          `;
        } else {
          document.getElementById('hostStatus').innerHTML = `
            <span class="error">❌ ${trans.error}: ${err.type}</span>
            <span class="user-nick">${userNickname}</span>
          `;
        }
      });

      peer.on('connection', (conn) => {
        if (isHost) {
          if (connections.length >= 7) {
            conn.close();
            return;
          }
          setupConnection(conn);
        } else {
          // Invitados solo aceptan conexiones P2P para sincronización de temporizadores
          peerConnections.set(conn.peer, conn);
          
          conn.on('data', (peerData) => {
            if (peerData.a === 'p2pHeartbeat') {
              // Responder heartbeat P2P - SOLO para mantener conexión
              try {
                conn.send({ a: 'p2pHeartbeatAck', from: myPeerId });
              } catch (e) {}
            } else if (peerData.a === 'p2pHeartbeatAck') {
              // Heartbeat confirmado - conexión viva
            } else {
              // Solo manejar eventos de temporizadores, no información de jugadores
              handleSync(peerData);
            }
          });
          
          conn.on('close', () => {
            peerConnections.delete(conn.peer);
          });
        }
      });
    }

    // ====================== CONFIGURAR CONEXIÓN ======================
    function setupConnection(conn) {
      let connectionTimeout = setTimeout(() => {
        if (!conn.open) conn.close();
      }, 10000);

      conn.on('open', () => {
        clearTimeout(connectionTimeout);
        connections.push(conn);
        
        conn.on('data', (data) => {
          if (!validateEventData(data)) return;
          
          if (data.a === 'playerInfo') {
            // 2.1. Recibir información del invitado
            const sanitizedNick = sanitizeNickname(data.nick);
            
            // 2.2. Actualizar lista de jugadores
            connectedPlayers.set(data.from, { 
              nick: sanitizedNick, 
              champion: data.champion, 
              color: data.color, 
              lastPong: Date.now() 
            });
            
            // Trackear orden de entrada
            if (!joinOrder.includes(data.from)) {
              joinOrder.push(data.from);
            }
            
            const guestPlayers = Array.from(connectedPlayers.keys()).filter(id => !connectedPlayers.get(id).isSelf);
            
            // 2.4. Asignar host secundario (primer invitado)
            if (guestPlayers.length === 1) {
              secondaryHostId = data.from;
              secondaryHostBackupId = generateShortId();
            }
            
            updatePlayersBar();
            
            // PASO 3: Enviar información actualizada
            const playersList = Array.from(connectedPlayers.entries())
              .filter(([key, value]) => !value.isSelf)
              .map(([key, value]) => [key, { nick: value.nick, champion: value.champion, color: value.color }]);
            playersList.unshift([myPeerId, { nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor }]);
            
            // 4.4. Enviar A TODOS LOS INVITADOS la información actualizada
            // Asegurar que myBackupId existe
            if (!myBackupId) {
              myBackupId = generateShortId();
            }
            
            const updateData = {
              a: 'connectionSuccess',
              playersList: playersList,
              hostBackupId: myBackupId,
              secondaryHostId: secondaryHostId,
              secondaryHostBackupId: secondaryHostBackupId
            };
            
            // Enviar a todos los invitados conectados
            connections.forEach(connection => {
              if (connection.open) {
                const isSecondaryHost = (connection.peer === secondaryHostId);

                const personalizedData = {
                  ...updateData,
                  youAreSecondaryHost: isSecondaryHost,
                  yourBackupId: isSecondaryHost ? secondaryHostBackupId : null
                };
                connection.send(personalizedData);
              }
            });
            
            // PASO 4: Establecer conexiones P2P para temporizadores
            const otherPlayers = Array.from(connectedPlayers.keys()).filter(id => id !== data.from && id !== myPeerId);
            if (otherPlayers.length > 0) {
              conn.send({ a: 'peerList', peers: otherPlayers });
            }
            
            sendFullState(conn);
            
            broadcastPlayerList();
            
            // Broadcast new player info to all existing connections
            connections.forEach(otherConn => {
              if (otherConn !== conn && otherConn.open) {
                try {
                  otherConn.send({ a: 'playerJoined', playerId: data.from, nick: sanitizedNick, champion: data.champion, color: data.color });
                  // Send existing players info to new connection
                  const existingPlayer = connectedPlayers.get(otherConn.peer);
                  if (existingPlayer) {
                    conn.send({ a: 'playerJoined', playerId: otherConn.peer, nick: existingPlayer.nick, champion: existingPlayer.champion, color: existingPlayer.color });
                  }
                } catch (e) {}
              }
            });
            
            // Send host info to new player
            conn.send({ a: 'playerJoined', playerId: myPeerId, nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor });
          } else if (data.a === 'hostInfo') {
            hostNickname = sanitizeNickname(data.nick);
          } else if (data.a === 'heartbeat') {
            // Recibir heartbeat de invitado - SOLO para mantener conexión viva
            const player = connectedPlayers.get(data.from);
            if (player) {
              player.lastPong = Date.now();
            }
            conn.send({ a: 'heartbeatAck', from: myPeerId });
          } else if (data.a === 'heartbeatAck') {
            // Host recibe confirmación de heartbeat enviado
            const player = connectedPlayers.get(data.from);
            if (player) player.lastPong = Date.now();
            pendingPings.delete(data.from);
          } else if (data.a === 'secondaryHostBackupId') {
            // Recibir ID de respaldo del host secundario y compartirla
            secondaryHostBackupId = data.id;
            
            // Enviar a todos los jugadores conectados
            sendEvent({
              a: 'secondaryHostIdUpdate',
              secondaryHostId: data.from,
              secondaryHostBackupId: data.id
            });
          } else if (data.a === 'newHost') {
            hostNickname = sanitizeNickname(data.nick);
            updatePlayersBar();
          } else if (data.a === 'requestBackupId') {
            // Enviar mi ID de respaldo cuando el host la solicite
            conn.send({ a: 'secondaryHostBackupId', id: myBackupId, from: myPeerId });
          } else {
            // RETRANSMITIR EVENTOS DE JUEGO A OTROS CLIENTES
            if (['start', 'reset', 'adjust', 'startSecondary', 'resetSecondary', 'changeSpell', 'startGame', 'resetAll', 'unleashedTeleport', 'secondaryHostDesignated', 'secondaryHostIdUpdate'].includes(data.a)) {
              // Retransmitir a todos los otros clientes conectados
              connections.forEach(otherConn => {
                if (otherConn !== conn && otherConn.open) {
                  try {
                    otherConn.send(data);
                  } catch (e) {}
                }
              });
            }
          }
          handleSync(data);
        });

        conn.on('close', () => {
          const disconnectedPeerId = conn.peer;
          
          // 5.2. Actualizar lista de jugadores
          connectedPlayers.delete(disconnectedPeerId);
          connections = connections.filter(c => c.peer !== disconnectedPeerId);
          pendingPings.delete(disconnectedPeerId);
          
          // Remover del orden de entrada
          joinOrder = joinOrder.filter(id => id !== disconnectedPeerId);
          
          // 5.1. Comprobar si quien se desconectó es el host secundario
          if (disconnectedPeerId === secondaryHostId) {
            // 5.1.1. Borrar información de backupID y secondaryHost
            secondaryHostId = null;
            secondaryHostBackupId = null;
            
            // 5.1.2. Asignar nuevo host secundario (siguiente en orden de entrada)
            const guestPlayers = joinOrder.filter(id => connectedPlayers.has(id));
            if (guestPlayers.length > 0) {
              secondaryHostId = guestPlayers[0];
              secondaryHostBackupId = generateShortId();
            }
          }
          
          // 5.3. Enviar nueva información a TODOS los invitados
          const playersList = Array.from(connectedPlayers.entries())
            .map(([key, value]) => [key, { nick: value.nick, champion: value.champion, color: value.color }]);
          playersList.unshift([myPeerId, { nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor }]);
          
          const updateData = {
            a: 'connectionSuccess',
            playersList: playersList,
            hostBackupId: myBackupId,
            secondaryHostId: secondaryHostId,
            secondaryHostBackupId: secondaryHostBackupId
          };
          
          // Broadcast a todos los invitados conectados
          connections.forEach(connection => {
            if (connection.open) {
              const personalizedData = {
                ...updateData,
                youAreSecondaryHost: (connection.peer === secondaryHostId),
                yourBackupId: (connection.peer === secondaryHostId) ? secondaryHostBackupId : null
              };
              connection.send(personalizedData);
            }
          });
          
          updatePlayersBar();
          
          // 5.4. Mantener mensaje "Eres el host"
          if (connectedPlayers.size === 1) { // Solo queda el host
            // La promoción a host se refleja en hostStatus
          }
          
          updatePlayersBar();
          broadcastPlayerList();
        });
      });

      conn.on('error', () => {
        clearTimeout(connectionTimeout);
      });
    }

    // ====================== CONECTAR AL HOST ======================
    function connectToHost() {
      const trans = LocalizationManager.getTranslations();
      const hostIdInput = document.getElementById('hostIdInput');
      const hostShortId = hostIdInput.value.trim().toUpperCase();

      if (!/^[A-HJ-NP-Z2-9]{6}$/.test(hostShortId)) {
        document.getElementById('clientStatus').innerHTML = `
          <span class="error">❌ ${trans.invalidId}</span>
          <span class="user-nick">${sanitizeNickname(userNickname)}</span>
        `;
        return;
      }

      if (myConnection && (myConnection.open || myConnection._connecting)) {
        return;
      }

      document.getElementById('clientStatus').textContent = trans.connecting;

      // 2.1. Borrar información sobre si es host secundario y backupID
      secondaryHostId = null;
      secondaryHostBackupId = null;
      myBackupId = null;
      hostBackupId = null;
      
      // 1.1. Mostrar mensaje "Conectando"
      // Estado de conectando se muestra en clientStatus
      
      const hostPeerId = `${hostShortId}_host`;
      myConnection = peer.connect(hostPeerId);

      let connectionTimeout = setTimeout(() => {
        if (myConnection && !myConnection.open) {
          myConnection.close();
          document.getElementById('clientStatus').innerHTML = `
            <span class="error">❌ Connection timeout</span>
            <span class="user-nick">${sanitizeNickname(userNickname)}</span>
          `;
        }
      }, 15000);

      myConnection.on('open', () => {
        clearTimeout(connectionTimeout);
        
        setTimeout(() => {
          // 2.2. Enviar información al host
          myConnection.send({ a: 'playerInfo', nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor, from: myPeerId });
        
        // Iniciar heartbeat
        heartbeatInterval = setInterval(() => {
          if (myConnection && myConnection.open) {
            myConnection.send({ a: 'heartbeat', from: myPeerId });
          }
        }, 2000);
        }, 50);
        
        myConnection.on('data', (data) => {
          if (!validateEventData(data)) return;
          
          if (data.a === 'heartbeat') {
            // Responder al heartbeat del HOST
            myConnection.send({ a: 'heartbeatAck', from: myPeerId });
          } else if (data.a === 'hostInfo') {
            hostNickname = sanitizeNickname(data.nick);
            hadHostConnection = true;
            // Update host info with champion
            const hostPlayer = connectedPlayers.get(data.from);
            if (hostPlayer) {
              hostPlayer.champion = data.champion;
            } else {
              connectedPlayers.set(data.from, { nick: hostNickname, champion: data.champion, color: data.color, lastPong: Date.now() });
            }
            const trans = LocalizationManager.getTranslations();
            document.getElementById('clientStatus').innerHTML = `
              <span>✅ ${trans.connected} <strong>${escapeHtml(hostNickname)}</strong></span>
              <span class="user-nick">${sanitizeNickname(userNickname)}</span>
            `;
            updatePlayersBar();
          } else if (data.a === 'playerList') {
            const list = new Map(data.players);
            connectedPlayers.clear();
            connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
            list.forEach((value, key) => {
              if (key !== myPeerId) {
                connectedPlayers.set(key, { ...value, nick: sanitizeNickname(value.nick), champion: value.champion, color: value.color, lastPong: Date.now() });
              }
            });
            updatePlayersBar();
          } else if (data.a === 'backupId') {
            // Almacenar ID de respaldo del jugador
            playerBackupIds.set(data.from, data.id);
            
            // Si es el host secundario, guardar su ID de respaldo
            if (data.from === secondaryHostId) {
              secondaryHostBackupId = data.id;
              updatePlayersBar(); // Actualizar UI inmediatamente
            }
          } else if (data.a === 'secondaryHostInfo') {
            // Recibir información del host secundario
            secondaryHostId = data.secondaryHostId;
            
            // Guardar ID de respaldo del host secundario
            if (secondaryHostId === myPeerId) {
              secondaryHostBackupId = myBackupId;
            } else {
              // Si no soy el host secundario, buscar su ID en playerBackupIds
              secondaryHostBackupId = playerBackupIds.get(secondaryHostId);
            }
            
            updatePlayersBar(); // Actualizar UI inmediatamente
          } else if (data.a === 'secondaryHostBackupId') {
            // Solo recibir backup ID del host secundario
            if (data.from === secondaryHostId) {
              secondaryHostBackupId = data.id;
              updatePlayersBar();
            }
            
            // El host ya envió mi backup ID
          } else if (data.a === 'peerList') {
            // 3. Establecer conexiones P2P EXCLUSIVAMENTE para temporizadores
            data.peers.forEach(peerId => {
              if (!peerConnections.has(peerId)) {
                const peerConn = peer.connect(peerId);
                peerConn.on('open', () => {
                  peerConnections.set(peerId, peerConn);
                  
                  // 3.1. Heartbeat SOLO para mantener conexión viva
                  const heartbeat = setInterval(() => {
                    if (peerConn.open) {
                      try {
                        peerConn.send({ a: 'p2pHeartbeat', from: myPeerId });
                      } catch (e) {
                        clearInterval(heartbeat);
                      }
                    } else {
                      clearInterval(heartbeat);
                    }
                  }, 5000);
                  
                  peerConn.heartbeatInterval = heartbeat;
                });
                
                peerConn.on('data', (peerData) => {
                  if (peerData.a === 'p2pHeartbeat') {
                    // Responder heartbeat P2P - SOLO para mantener conexión
                    try {
                      peerConn.send({ a: 'p2pHeartbeatAck', from: myPeerId });
                    } catch (e) {}
                  } else if (peerData.a === 'p2pHeartbeatAck') {
                    // Heartbeat confirmado - conexión viva
                  } else {
                    // Solo manejar eventos de temporizadores
                    handleSync(peerData);
                  }
                });
                
                peerConn.on('close', () => {
                  if (peerConn.heartbeatInterval) {
                    clearInterval(peerConn.heartbeatInterval);
                  }
                  peerConnections.delete(peerId);
                });
              }
            });
          } else if (data.a === 'heartbeatAck') {
            // HOST confirmó recepción de nuestro heartbeat - conexión viva
            if (hostLostTimeout) clearTimeout(hostLostTimeout);
            hostLostTimeout = setTimeout(() => {
              // Si no recibimos heartbeat del host en 5s, considerarlo perdido
              if (secondaryHostId === myPeerId) {
                isHost = true;
                shortId = hostBackupId; // Usar el backupID del host original
                hostNickname = sanitizeNickname(userNickname);
                initializeHost();
                setupSyncPanel();
                initPeer();
              } else {
                attemptReconnectionWithRetries();
              }
            }, 5000);
          } else if (data.a === 'fullState') {
            applyFullState(data.state);
          } else if (data.a === 'newHostAnnouncement') {
            hostNickname = sanitizeNickname(data.nick);
            const trans = LocalizationManager.getTranslations();
            document.getElementById('clientStatus').innerHTML = `
              <span>✅ ${trans.connected} <strong>${escapeHtml(hostNickname)}</strong></span>
              <span class="user-nick">${sanitizeNickname(userNickname)}</span>
            `;
            updatePlayersBar();
          } else if (data.a === 'playerJoined') {
            // Update player info when someone new joins
            connectedPlayers.set(data.playerId, { nick: sanitizeNickname(data.nick), champion: data.champion, color: data.color, lastPong: Date.now() });
            updatePlayersBar();
            
            // Propagar información a conexiones P2P
            peerConnections.forEach(peerConn => {
              if (peerConn.open && peerConn.peer !== data.playerId) {
                try {
                  peerConn.send({ a: 'playerJoined', playerId: data.playerId, nick: sanitizeNickname(data.nick), champion: data.champion, color: data.color });
                } catch (e) {}
              }
            });
          } else if (data.a === 'becomeHost') {
            isHost = true;
            hostNickname = sanitizeNickname(userNickname);
            setupSyncPanel();
            initPeer();
            updatePlayersBar();
          }
          handleSync(data);
        });

        myConnection.on('close', () => {
          clearTimeout(connectionTimeout);
          if (heartbeatInterval) clearInterval(heartbeatInterval);
          
          // 6. Cuando pierde conexión con el host
          if (secondaryHostId === myPeerId) {
            // 6.1.1. Soy host secundario - convertirme en host
            isHost = true;
            shortId = hostBackupId; // Usar el backupID del host original
            hostNickname = sanitizeNickname(userNickname);
            
            // 6.1.2. Preservar información de jugadores antes de ascender
            const existingPlayers = new Map(connectedPlayers);
            const existingPeerConnections = new Map(peerConnections);
            const preservedSecondaryHostId = secondaryHostId; // Preservar antes de initializeHost
            
            initializeHost();
            setupSyncPanel();
            initPeer();
            
            // Restaurar jugadores y conexiones
            setTimeout(() => {
              existingPeerConnections.forEach((peerConn, peerId) => {
                // CRITICAL: Excluir myPeerId para evitar duplicados en connectedPlayers
                if (peerConn.open && peerId !== myPeerId) {
                  connections.push(peerConn);
                  // Restaurar información completa del jugador
                  const playerInfo = existingPlayers.get(peerId);
                  if (playerInfo) {
                    connectedPlayers.set(peerId, {
                      nick: playerInfo.nick,
                      champion: playerInfo.champion,
                      color: playerInfo.color,
                      lastPong: Date.now()
                    });
                  }
                }
              });
              
              // Designar nuevo host secundario del primer invitado
              const guestPlayers = Array.from(connectedPlayers.keys()).filter(id => !connectedPlayers.get(id)?.isSelf);
              if (guestPlayers.length > 0) {
                secondaryHostId = guestPlayers[0];
                secondaryHostBackupId = generateShortId();
                
                // Enviar información actualizada a todos
                broadcastPlayerList();
              }
              
              updatePlayersBar();
            }, 500);
            
          } else {
            // 6.2. No soy host secundario - intentar reconectar
            attemptReconnectionWithRetries();
          }
          
          myConnection = null;
        });
      });

      myConnection.on('error', (err) => {
        clearTimeout(connectionTimeout);
        
        // 1.2. Mensaje de error para ID incorrecta
        // Error se muestra en clientStatus
        
        const trans = LocalizationManager.getTranslations();
        document.getElementById('clientStatus').innerHTML = `
          <span class="error">❌ ${trans.error}: ${err.type}</span>
          <span class="user-nick">${sanitizeNickname(userNickname)}</span>
        `;
        myConnection = null;
        
        document.getElementById('joinBtn').disabled = false;
        document.getElementById('joinBtn').textContent = lang === 'es' ? 'Unirse' : 'Join';
      });
    }

    // ====================== MONITOREO DEL HOST ======================
    function startHostMonitoring() {
      // HOST: Heartbeat bidireccional cada 3s (consistente con invitados)
      pingInterval = setInterval(() => {
        const now = Date.now();
        connections.forEach(conn => {
          try {
            conn.send({ a: 'heartbeat', from: myPeerId });
            pendingPings.set(conn.peer, now);
          } catch (e) {}
        });
      }, 2000);

      cleanupInterval = setInterval(() => {
        const now = Date.now();
        let changed = false;
        connectedPlayers.forEach((player, peerId) => {
          if (player.isSelf) return;
          const conn = connections.find(c => c.peer === peerId);
          // Heartbeat cada 3s - si no responde en 12s, desconectado
          if (now - player.lastPong > 12000 && (!conn || !conn.open)) {
            connectedPlayers.delete(peerId);
            connections = connections.filter(c => c.peer !== peerId);
            pendingPings.delete(peerId);
            
            // Si el host secundario se desconecta, designar nuevo host secundario
            if (peerId === secondaryHostId) {
              const guestPlayers = Array.from(connectedPlayers.keys()).filter(id => !connectedPlayers.get(id).isSelf);
              if (guestPlayers.length > 0) {
                secondaryHostId = guestPlayers[0];
                secondaryHostBackupId = playerBackupIds.get(secondaryHostId) || null;
                sendEvent({
                  a: 'secondaryHostDesignated',
                  secondaryHostId: secondaryHostId,
                  joinOrder: guestPlayers
                });
                
                // Enviar información específica al nuevo host secundario
                const newSecondaryConn = connections.find(c => c.peer === secondaryHostId);
                if (newSecondaryConn && newSecondaryConn.open) {
                  newSecondaryConn.send({ a: 'secondaryHostInfo', secondaryHostId, joinOrder: guestPlayers });
                  if (secondaryHostBackupId) {
                    newSecondaryConn.send({ a: 'secondaryHostIdUpdate', secondaryHostId, secondaryHostBackupId });
                  }
                  // Solicitar ID de respaldo del nuevo host secundario
                  newSecondaryConn.send({ a: 'requestBackupId', from: myPeerId });
                }
                
                // Forzar actualización de UI
                updatePlayersBar();
              } else {
                secondaryHostId = null;
                secondaryHostBackupId = null;
              }
            }
            
            changed = true;
          }
        });
        if (changed) {
          updatePlayersBar();
          broadcastPlayerList();
        }
      }, 2000);
    }

    // ====================== SINCRONIZACIÓN ======================
    function sendEvent(data) {
      if (isSoloMode) return;
      
      const event = { ...data, from: myPeerId, nick: userNickname };
      if (isHost) {
        connections.forEach(conn => {
          if (conn.open) {
            try {
              conn.send(event);
            } catch (e) {}
          }
        });
      } else {
        // Enviar solo al host - el host se encarga de retransmitir
        if (myConnection && myConnection.open) {
          try {
            myConnection.send(event);
          } catch (e) {}
        }
      }
    }

    function sendFullState(conn) {
      const state = {
        primary: timerBoxes.map((box, i) => ({
          i,
          active: !!box.interval,
          seconds: parseInt(box.dataset.seconds) || DURATIONS.PRIMARY,
          completed: box.classList.contains('completed'),
          startTime: box.startTime || null
        })),
        secondary: staticTimers.map((el, i) => {
          const spell = spellSelects[i].value;
          return {
            i,
            active: !!el.interval,
            seconds: SpellManager.isSmite(spell) ? 0 : (parseInt(el.dataset.seconds) || parseInt(el.dataset.initialDuration)),
            spell: spell,
            completed: el.classList.contains('completed'),
            startTime: el.startTime || null
          };
        }),
        gameTimer: {
          active: isGameStarted,
          seconds: gameTimerEl.classList.contains('active') ? parseTime(gameTimerEl.textContent) : DURATIONS.GAME,
          startTime: gameTimerEl.startTime || null
        }
      };
      conn.send({ a: 'fullState', state, from: myPeerId, nick: userNickname });
    }

    function parseTime(timeStr) {
      if (timeStr === 'Unleashed Teleport!') return 0;
      const [min, sec] = timeStr.split(':').map(Number);
      return min * 60 + sec;
    }

    function handleSync(data) {
      if (data.from === myPeerId) return;
      if (!validateEventData(data)) return;

      if (data.a === 'connectionSuccess') {
        // 2.2. Recibir lista de jugadores actualizada
        connectedPlayers.clear();
        connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
        
        data.playersList.forEach(([playerId, playerData]) => {
          if (playerId !== myPeerId) {
            connectedPlayers.set(playerId, { 
              nick: sanitizeNickname(playerData.nick), 
              champion: playerData.champion, 
              color: playerData.color, 
              lastPong: Date.now() 
            });
          }
        });
        
        // 5.2. Eliminar conexiones P2P con jugadores desconectados
        const currentPlayerIds = new Set(data.playersList.map(([id]) => id));
        peerConnections.forEach((peerConn, peerId) => {
          if (!currentPlayerIds.has(peerId)) {
            // Jugador ya no está en la lista - cerrar conexión P2P
            if (peerConn.heartbeatInterval) {
              clearInterval(peerConn.heartbeatInterval);
            }
            try {
              peerConn.close();
            } catch (e) {}
            peerConnections.delete(peerId);
          }
        });
        
        // 2.3. Actualizar información interna backupID y host secundario
        hostBackupId = data.hostBackupId;
        
        if (data.youAreSecondaryHost) {
          secondaryHostId = myPeerId;
          secondaryHostBackupId = data.yourBackupId;
          myBackupId = data.yourBackupId;
        } else {
          if (data.secondaryHostId) {
            secondaryHostId = data.secondaryHostId;
            secondaryHostBackupId = data.secondaryHostBackupId;
          }
        }
        
        // 2.4. Actualizar caja de jugadores UNA VEZ
        updatePlayersBar();
        
        // 2.5. Mensaje "Conectado a [nombre del host]"
        const hostPlayer = data.playersList.find(([id]) => id === Object.keys(data.playersList[0] === myPeerId ? data.playersList[1] : data.playersList[0]));
        const hostName = data.playersList[0][1].nick; // El host siempre es el primero
        
        // Actualizar estado en lugar de toast
        const trans = LocalizationManager.getTranslations();
        document.getElementById('clientStatus').innerHTML = `
          <span class="success">✅ ${trans.connected} <strong>${escapeHtml(hostName)}</strong></span>
          <span class="user-nick">${sanitizeNickname(userNickname)}</span>
        `;
        
        return;
      }
      
      // 4. Cuando entra otro invitado - 5. Cuando un invitado se desconecta
      // Ambos casos se manejan con connectionSuccess del host
      
      if (data.a === 'playerJoined') {
        connectedPlayers.set(data.playerId, { nick: sanitizeNickname(data.nick), champion: data.champion, color: data.color, lastPong: Date.now() });
        updatePlayersBar();
        return;
      }

      
      if (data.a === 'hostLost') {
        // Otro peer me notifica que perdió conexión con el host
        if (myConnection && myConnection.open) {
          // Aún tengo conexión, ignorar
          return;
        }
        
        // Solo el host secundario designado puede ascender
        if (secondaryHostId === myPeerId) {
          // Soy el host secundario, ascender inmediatamente
          setTimeout(() => {
            isHost = true;
            shortId = myBackupId;
            hostNickname = sanitizeNickname(userNickname);
            setupSyncPanel();
            initPeer();
          }, 1000);
        } else {
          // Intentar reconectar con host secundario
          setTimeout(() => {
            if (secondaryHostBackupId) {
              connectToSecondaryHost();
            } else {
              tryConnectToBackupHosts();
            }
          }, 2000);
        }
        return;
      }
      
      if (data.a === 'secondaryHostDesignated') {
        secondaryHostId = data.secondaryHostId;
        
        // Si soy el host secundario, enviar mi ID al host principal
        if (secondaryHostId === myPeerId) {
          secondaryHostBackupId = myBackupId;
          
          // Enviar mi ID de respaldo al host principal
          if (myConnection && myConnection.open) {
            myConnection.send({ a: 'secondaryHostBackupId', id: myBackupId, from: myPeerId });
          }
          
          // Monitorear conexión para ascender automáticamente
          const checkConnection = setInterval(() => {
            if (!myConnection || !myConnection.open) {
              clearInterval(checkConnection);
              isHost = true;
              shortId = myBackupId;
              hostNickname = sanitizeNickname(userNickname);
              
              // Mantener conexiones P2P existentes y reconfigurarlas como host
              connections = Array.from(peerConnections.values()).filter(conn => conn.open);
              
              // Reconfigurar cada conexión para que tenga los listeners de host
              connections.forEach(conn => {
                // Remover listeners P2P existentes
                conn.removeAllListeners('data');
                
                // Configurar listener de host (idéntico a setupConnection)
                conn.on('data', (data) => {
                  if (!validateEventData(data)) return;
                  
                  if (data.a === 'playerInfo') {
                    const sanitizedNick = sanitizeNickname(data.nick);
                    const existingPlayer = connectedPlayers.get(data.from);
                    let hasChanged = false;
                    
                    if (!existingPlayer) {
                      connectedPlayers.set(data.from, { nick: sanitizedNick, lastPong: Date.now(), champion: data.champion, color: data.color });
                      hasChanged = true;
                    } else {
                      if (existingPlayer.nick !== sanitizedNick) {
                        existingPlayer.nick = sanitizedNick;
                        hasChanged = true;
                      }
                      if (existingPlayer.champion !== data.champion) {
                        existingPlayer.champion = data.champion;
                        hasChanged = true;
                      }
                      if (existingPlayer.color !== data.color) {
                        existingPlayer.color = data.color;
                        hasChanged = true;
                      }
                      existingPlayer.lastPong = Date.now();
                    }
                    
                    if (hasChanged) {
                      updatePlayersBar();
                      // Retransmitir a todos los otros invitados
                      connections.forEach(otherConn => {
                        if (otherConn !== conn && otherConn.open) {
                          try {
                            otherConn.send({ a: 'playerUpdate', playerId: data.from, nick: sanitizedNick, champion: data.champion, color: data.color });
                          } catch (e) {}
                        }
                      });
                    }
                  } else {
                    // Manejar otros eventos y retransmitir
                    if (['start', 'reset', 'adjust', 'startSecondary', 'resetSecondary', 'changeSpell', 'startGame', 'resetAll', 'unleashedTeleport', 'secondaryHostDesignated', 'secondaryHostIdUpdate'].includes(data.a)) {
                      connections.forEach(otherConn => {
                        if (otherConn !== conn && otherConn.open) {
                          try {
                            otherConn.send(data);
                          } catch (e) {}
                        }
                      });
                    }
                  }
                  handleSync(data);
                });
              });
              
              // Restaurar jugadores de conexiones P2P
              connectedPlayers.clear();
              connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
              peerConnections.forEach((conn, peerId) => {
                if (conn.open) {
                  connectedPlayers.set(peerId, { nick: 'Player', lastPong: Date.now() });
                }
              });
              
              // Regenerar orden y designar nuevo host secundario
              const guestPlayers = Array.from(peerConnections.keys()).filter(id => peerConnections.get(id).open);
              if (guestPlayers.length > 0) {
                secondaryHostId = guestPlayers[0];
                
                // Generar nueva backup ID si no existe
                if (!playerBackupIds.has(secondaryHostId)) {
                  playerBackupIds.set(secondaryHostId, generateShortId());
                }
                secondaryHostBackupId = playerBackupIds.get(secondaryHostId);
                
                // Notificar nuevo host secundario después de inicializar
                setTimeout(() => {
                  sendEvent({
                    a: 'secondaryHostDesignated',
                    secondaryHostId: secondaryHostId,
                    joinOrder: guestPlayers
                  });
                  
                  // Enviar backup ID al nuevo host secundario
                  const newSecondaryConn = connections.find(c => c.peer === secondaryHostId);
                  if (newSecondaryConn && newSecondaryConn.open) {
                    newSecondaryConn.send({ a: 'backupId', id: secondaryHostBackupId, from: myPeerId });
                    newSecondaryConn.send({ a: 'secondaryHostIdUpdate', secondaryHostId, secondaryHostBackupId });
                  }
                }, 2000);
              } else {
                secondaryHostId = null;
                secondaryHostBackupId = null;
              }
              
              setupSyncPanel();
              initPeer();
            }
          }, 1000);
        } else {
          // Si ya tengo la ID del host secundario, almacenarla
          const existingId = playerBackupIds.get(secondaryHostId);
          if (existingId) {
            secondaryHostBackupId = existingId;
          }
        }
        
        // Limpiar duplicados en connectedPlayers
        const uniquePlayers = new Map();
        connectedPlayers.forEach((player, id) => {
          if (!uniquePlayers.has(id)) {
            uniquePlayers.set(id, player);
          }
        });
        connectedPlayers.clear();
        uniquePlayers.forEach((player, id) => {
          connectedPlayers.set(id, player);
        });
        
        updatePlayersBar();
        return;
      }
      
      if (data.a === 'secondaryHostIdUpdate') {
        secondaryHostId = data.secondaryHostId;
        secondaryHostBackupId = data.secondaryHostBackupId;
        updatePlayersBar();
        return;
      }

      if (data.a === 'start') {
        const box = timerBoxes[data.i];
        if (box && !box.interval) {
          box.dataset.seconds = DURATIONS.PRIMARY;
          if (data.startTime) {
            const elapsed = Math.floor((new Date().getTime() - data.startTime) / 1000);
            const currentSeconds = Math.max(0, DURATIONS.PRIMARY - elapsed);
            box.dataset.seconds = currentSeconds;
            box.startTime = data.startTime;
          }
          startTimer(box, false);
        }
      }

      if (data.a === 'reset') {
        const box = timerBoxes[data.i];
        if (box) {
          box.startTime = null;
          resetTimer(box, false);
        }
      }

      if (data.a === 'adjust') {
        const box = timerBoxes[data.i];
        if (box && box.classList.contains('active')) {
          adjustTime(box, data.s, false);
        }
      }

      if (data.a === 'startSecondary') {
        const el = staticTimers[data.i];
        if (el && !el.interval) {
          const initialDuration = parseInt(el.dataset.initialDuration);
          el.dataset.seconds = initialDuration;
          if (data.startTime) {
            const elapsed = Math.floor((new Date().getTime() - data.startTime) / 1000);
            const currentSeconds = Math.max(0, initialDuration - elapsed);
            el.dataset.seconds = currentSeconds;
            el.startTime = data.startTime;
          }
          startStaticTimer(el);
          const row = el.parentElement;
          row.classList.add('secondary-active');
        }
      }

      if (data.a === 'resetSecondary') {
        const el = staticTimers[data.i];
        const select = spellSelects[data.i];
        if (el) {
          el.startTime = null;
          resetStaticTimer(el, select);
        }
      }

      if (data.a === 'changeSpell') {
        const el = staticTimers[data.i];
        const select = spellSelects[data.i];
        if (el && select) {
          select.value = data.spell;
          
          // Usar SpellManager para cambiar hechizo y resetear si estaba activo
          SpellManager.changeSpell(el, select, data.spell, formatTime, updateStaticTimerStyle);
        }
      }

      if (data.a === 'startGame') {
        if (!isGameStarted) {
          if (gameTimerInterval) clearInterval(gameTimerInterval);
          gameTimerInterval = null;
          let totalSeconds = DURATIONS.GAME;
          gameTimerEl.textContent = formatTime(totalSeconds);
          gameTimerEl.classList.add('active');

          gameTimerInterval = setInterval(() => {
            totalSeconds--;
            gameTimerEl.textContent = formatTime(totalSeconds);
            if (totalSeconds <= 0) {
              clearInterval(gameTimerInterval);
              gameTimerInterval = null;
              gameTimerEl.textContent = 'Unleashed Teleport!';
              updateTeleportDuration(240);
            }
          }, 1000);
          isGameStarted = true;
          mainActionBtn.textContent = 'Reset All';
        }
      }

      if (data.a === 'resetAll') {
        timerBoxes.forEach(box => box.startTime = null);
        staticTimers.forEach(el => el.startTime = null);
        resetAll(false);
      }

      if (data.a === 'unleashedTeleport') {
        updateTeleportDuration(240);
      }
    }

    function applyFullState(state) {
      // Aplicar temporizadores primarios
      state.primary.forEach(timerData => {
        const box = timerBoxes[timerData.i];
        if (!box) return;

        if (box.interval) {
          clearInterval(box.interval);
          box.interval = null;
        }

        box.classList.remove('active', 'completed');
        const row = box.parentElement;
        row.classList.remove('active');

        const timeSpan = box.querySelector('.time');
        timeSpan.textContent = formatTime(timerData.seconds);
        box.dataset.seconds = timerData.seconds;

        if (timerData.completed) {
          box.classList.add('completed');
        } else if (timerData.active) {
          startTimer(box, false);
        }
      });

      // Aplicar temporizadores secundarios
      state.secondary.forEach(secData => {
        const el = staticTimers[secData.i];
        const select = spellSelects[secData.i];
        if (!el || !select) return;

        if (el.interval) {
          clearInterval(el.interval);
          el.interval = null;
        }

        el.classList.remove('active', 'completed');
        const row = el.parentElement;
        row.classList.remove('secondary-active');

        const timeSpan = el.querySelector('span');
        select.value = secData.spell;
        const spellInfo = spellData[secData.spell];
        if (spellInfo) {
          el.style.backgroundImage = `url(${spellInfo.icon})`;
          el.dataset.initialDuration = spellInfo.duration;
          
          // Aplicar lógica de smite
          SpellManager.applySmiteLogic(el, secData.spell);
        }

        if (secData.completed) {
          el.classList.add('completed');
          el.dataset.seconds = parseInt(el.dataset.initialDuration);
          if (!SpellManager.isSmite(secData.spell)) {
            timeSpan.textContent = formatTime(el.dataset.seconds);
          }
        } else if (secData.active) {
          el.dataset.seconds = secData.seconds;
          if (secData.startTime) {
            el.startTime = secData.startTime;
          }
          if (!SpellManager.isSmite(secData.spell)) {
            timeSpan.textContent = formatTime(secData.seconds);
          }
          startStaticTimer(el);
          row.classList.add('secondary-active');
        } else {
          el.dataset.seconds = secData.seconds;
          if (!SpellManager.isSmite(secData.spell)) {
            timeSpan.textContent = formatTime(secData.seconds);
          }
        }
      });
    }

    // ====================== JUGADORES CONECTADOS ======================
    function updatePlayersBar() {
      const trans = LocalizationManager.getTranslations();
      const playerCountEl = document.getElementById('playerCount');
      const secondaryHostInfo = document.getElementById('secondary-host-info');
      
      // Mostrar info del host secundario expandida
      if (secondaryHostId && secondaryHostBackupId) {
        const secondaryPlayer = connectedPlayers.get(secondaryHostId);
        const secondaryNick = secondaryPlayer ? secondaryPlayer.nick : (secondaryHostId === myPeerId ? sanitizeNickname(userNickname) : 'Player');
        
        const isMe = secondaryHostId === myPeerId;
        const meIndicator = isMe ? ' (YOU)' : '';
        const statusColor = isMe ? '#4CAF50' : '#888';
        
        secondaryHostInfo.innerHTML = `
          <div style="color: ${statusColor}; font-weight: ${isMe ? 'bold' : 'normal'};">
            🔄 Next Host: ${secondaryNick}${meIndicator}<br>
            📋 BackupID: ${secondaryHostBackupId}<br>
            ${isMe ? '⚡ You will become host if current host disconnects' : ''}
          </div>
        `;
      } else if (hostBackupId) {
        // Mostrar información para invitados
        secondaryHostInfo.innerHTML = `
          <div style="color: #888;">
            📋 Host BackupID: ${hostBackupId}<br>
            ${secondaryHostId === myPeerId ? '⚡ You are the next host' : '❌ You are NOT the next host'}
          </div>
        `;
      } else {
        secondaryHostInfo.textContent = '';
      }
      
      if (connectedPlayers.size === 0) {
        if (!isHost && hadHostConnection) {
          document.getElementById('players-list').textContent = trans.playingSoloHostLost;
        } else {
          document.getElementById('players-list').textContent = trans.playingSolo;
        }
        if (playerCountEl) playerCountEl.style.display = 'none';
        return;
      }

      if (connectedPlayers.size === 1) {
        document.getElementById('players-list').textContent = trans.playingSolo;
        if (playerCountEl) playerCountEl.style.display = 'none';
        return;
      }
      
      if (playerCountEl) {
        playerCountEl.textContent = `${lang === 'es' ? 'Jugadores' : 'Players'}: ${connectedPlayers.size}/7`;
        playerCountEl.style.display = 'block';
      }

      const sorted = Array.from(connectedPlayers.entries())
        .sort(([keyA, a], [keyB, b]) => (a.isSelf ? -1 : b.isSelf ? 1 : 0));

      const list = sorted.map(([playerId, p]) => {
        let championImg = '';
        
        // Show champion image for any player who has one
        const championToShow = p.isSelf ? userChampion : p.champion;
        if (championToShow) {
          const fileName = getChampionFileName(championToShow);
          championImg = `<img src="./Champions_assets/${fileName}.png" style="width: 16px; height: 16px; border-radius: 2px; margin-right: 4px; vertical-align: middle;" onerror="this.style.display='none'">`;
        }
        
        // Apply user color with gradient support
        let userColorToShow = p.isSelf ? userColor : p.color;
        
        // Diana easter egg override - check for Diana names
        const isDianaName = p.nick === 'Diana, Scorn of the Moon' || p.nick === 'Diana, El desdén de la Luna';
        if (isDianaName) {
          userColorToShow = 'linear-gradient(45deg, #ffffff, #87ceeb)';
        }
        
        let colorStyle = '';
        if (userColorToShow) {
          if (userColorToShow.startsWith('linear-gradient')) {
            colorStyle = `background: ${userColorToShow}; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; display: inline-block;`;
          } else {
            colorStyle = `color: ${userColorToShow};`;
          }
        }
        
        let name;
        if (p.isSelf) {
          if (userColorToShow && userColorToShow.startsWith('linear-gradient')) {
            name = `${championImg}<strong style="${colorStyle}">${escapeHtml(p.nick)}</strong>`;
          } else {
            name = `${championImg}<strong style="color:#4caf50; ${colorStyle}">${escapeHtml(p.nick)}</strong>`;
          }
        } else {
          name = `${championImg}<span style="${colorStyle}">${escapeHtml(p.nick)}</span>`;
        }
        
        if ((isHost && p.isSelf) || (!isHost && p.nick === hostNickname)) {
          name += ' 👑';
        }
        
        return name;
      });

      document.getElementById('players-list').innerHTML = list.join(', ');
    }

    function broadcastPlayerList() {
      if (!isHost) return;
      
      const list = Array.from(connectedPlayers.entries())
        .filter(([key, value]) => !value.isSelf)
        .map(([key, value]) => [key, { nick: value.nick, champion: value.champion, color: value.color }]);
      
      list.unshift([myPeerId, { nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor }]);

      connections.forEach(conn => {
        if (conn.open) {
          try {
            conn.send({ a: 'playerList', players: list });
          } catch (e) {}
        }
      });
    }

    // ====================== ATAJOS DE TECLADO ======================
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) return;
      
      // Bloquear atajos si estamos escribiendo en el campo de ID del host
      const hostIdInput = document.getElementById('hostIdInput');
      if (hostIdInput && document.activeElement === hostIdInput) return;

      let key = null;
      if (e.code === 'Digit1') key = '1';
      else if (e.code === 'Digit2') key = '2';
      else if (e.code === 'Digit3') key = '3';
      else if (e.code === 'Digit4') key = '4';
      else if (e.code === 'Digit5') key = '5';
      else return;

      const index = keyMap[key];
      const box = timerBoxes[index];
      if (!box) return;

      if (e.altKey) {
        e.preventDefault();
        if (box.classList.contains('active')) {
          showButtonsWithTimeout(box);
          // Animar botón -10
          const btn10 = box.querySelector('.time-shortcut[data-sec="-10"]');
          if (btn10) {
            btn10.style.transform = 'scale(0.9)';
            btn10.style.background = 'var(--accent-primary)';
            setTimeout(() => {
              btn10.style.transform = '';
              btn10.style.background = '';
            }, 150);
          }
        }
        adjustTime(box, -10, true);
      } else if (e.shiftKey) {
        e.preventDefault();
        if (box.classList.contains('active')) {
          showButtonsWithTimeout(box);
          // Animar botón -30
          const btn30 = box.querySelector('.time-shortcut[data-sec="-30"]');
          if (btn30) {
            btn30.style.transform = 'scale(0.9)';
            btn30.style.background = 'var(--accent-primary)';
            setTimeout(() => {
              btn30.style.transform = '';
              btn30.style.background = '';
            }, 150);
          }
        }
        adjustTime(box, -30, true);
      } else {
        e.preventDefault();
        box.click();
      }
    });

    // ====================== ACTUALIZAR DURACIÓN DE TELEPORT ======================
    function updateTeleportDuration(newDuration) {
      if (newDuration === 240) {
        isTeleportUnleashed = true;
      }
      TimerManager.updateTeleportDuration(staticTimers, spellSelects, newDuration);
    }

    // ====================== INICIO ======================
    // Auto-join desde invitación
    function checkAutoJoin() {
      const autoJoinCode = launchConfig.autoJoin;
      
      if (autoJoinCode) {
        console.log('Auto-joining room:', autoJoinCode);
        
        // Esperar a que el panel esté configurado
        setTimeout(() => {
          const hostIdInput = document.getElementById('hostIdInput');
          if (hostIdInput) {
            hostIdInput.value = autoJoinCode;
            // Conectar automáticamente
            connectToHost();
          }
        }, 1000);
        
        return true;
      }
      return false;
    }

    document.addEventListener('DOMContentLoaded', () => {
      checkAutoJoin();
      // Configuración inicial
      ConfigManager.setupSwitches(lang, themeToUse);
      
      // Activar modo Diana si viene en la URL
      const dianaMode = launchConfig.diana === true;
      if (dianaMode) {
        document.body.classList.add('diana-mode');
        const title = document.getElementById('appTitle');
        if (lang === 'es') {
          title.innerHTML = `<span style="filter: grayscale(1) brightness(2);">🌙</span> Una nueva luna se alza <span style="filter: grayscale(1) brightness(2);">🌙</span>`;
        } else {
          title.innerHTML = `<span style="filter: grayscale(1) brightness(2);">🌙</span> A new moon is rising <span style="filter: grayscale(1) brightness(2);">🌙</span>`;
        }
        
        // Cambiar favicon
        const favicon = document.querySelector('link[rel="icon"]');
        favicon.href = './images/Diana.png';
      }
      
      // Crear temporizadores
      console.log('DOM loaded, creating timers...');
      
      // ====================== CREACIÓN DE TEMPORIZADORES ======================
      roles.forEach((role, i) => {
        const row = document.createElement('div');
        row.className = 'timer-row';

        const resetBtn = document.createElement('button');
        resetBtn.className = 'reset-btn';
        resetBtn.innerHTML = '×';
        resetBtn.title = LocalizationManager.getTranslations().reset;
        resetBtn.onclick = (e) => {
          e.stopPropagation();
          resetTimer(timerBoxes[i], true);
        };

        const roleIcon = document.createElement('div');
        roleIcon.className = 'role-icon';
        const img = document.createElement('img');
        img.src = icons[i];
        img.alt = role;
        img.title = role;
        img.onerror = function() { this.src = './images/Flash.png'; };
        roleIcon.appendChild(img);

        const box = document.createElement('div');
        box.className = 'timer-box';
        box.dataset.role = role;
        box.dataset.index = i;

        const message = document.createElement('div');
        message.className = 'reset-message';
        message.textContent = LocalizationManager.getTranslations().reset;
        box.appendChild(message);

        const notification = document.createElement('div');
        notification.className = 'time-notification';
        notification.textContent = '-10s';
        box.appendChild(notification);

        const feedback = document.createElement('div');
        feedback.className = 'feedback';
        feedback.textContent = '-10';
        box.appendChild(feedback);

        const roleName = document.createElement('span');
        roleName.className = 'role-name';
        roleName.textContent = lang === 'es' ? {
          'Top': 'Superior',
          'Jungle': 'Jungla',
          'Middle': 'Medio',
          'Bottom': 'Inferior',
          'Support': 'Soporte'
        }[role] : role;

        const controls = document.createElement('div');
        controls.style.display = 'flex';
        controls.style.alignItems = 'center';
        controls.style.gap = '6px';
        controls.innerHTML = `
          <button class="time-shortcut" data-sec="-10">-10</button>
          <button class="time-shortcut" data-sec="-30">-30</button>
          <span class="time">05:00</span>
        `;

        box.appendChild(roleName);
        box.appendChild(controls);

        // TEMPORIZADOR SECUNDARIO
        const staticTimer = document.createElement('div');
        staticTimer.className = 'static-timer';
        staticTimer.innerHTML = `<span>05:00</span>`;
        staticTimer.dataset.role = role;
        staticTimer.dataset.index = i;

        // Desplegable
        const select = document.createElement('select');
        select.className = 'spell-select';

        SpellManager.createSpellOptions().forEach(spellOption => {
          const option = document.createElement('option');
          option.value = spellOption.value;
          option.textContent = spellOption.text;
          select.appendChild(option);
        });

        const defaultSpell = defaultSpells[i];
        select.value = defaultSpell;
        const data = spellData[defaultSpell];
        staticTimer.dataset.seconds = data.duration;
        staticTimer.dataset.initialDuration = data.duration;
        staticTimer.querySelector('span').textContent = formatTime(data.duration);
        staticTimer.style.backgroundImage = `url(${data.icon})`;
        
        // Aplicar lógica de smite por defecto
        if (SpellManager.isSmite(defaultSpell)) {
          SpellManager.applySmiteLogic(staticTimer, defaultSpell);
        }

        select.addEventListener('change', () => {
          const spell = select.value;
          
          // Usar SpellManager para cambiar hechizo y resetear si estaba activo
          SpellManager.changeSpell(staticTimer, select, spell, formatTime, updateStaticTimerStyle);
          
          // Actualizar icono de rol si los desplegables están visibles
          const arrow = document.getElementById('toggleArrow');
          if (arrow.textContent.trim() === '⬅️') {
            const roleIcon = document.querySelectorAll('.role-icon')[i];
            const img = roleIcon.querySelector('img');
            img.src = SpellManager.getSpellData(spell).icon;
          }
          
          sendEvent({
            a: 'changeSpell',
            i: i,
            spell: spell
          });
        });

        // Botón de reinicio secundario
        const resetBtnSecondary = document.createElement('button');
        resetBtnSecondary.className = 'reset-btn-secondary';
        resetBtnSecondary.innerHTML = '×';
        resetBtnSecondary.title = 'Reset Spell';
        resetBtnSecondary.onclick = (e) => {
          e.stopPropagation();
          resetStaticTimer(staticTimer, select);
          sendEvent({
            a: 'resetSecondary',
            i: i
          });
        };

        row.appendChild(resetBtn);
        row.appendChild(roleIcon);
        row.appendChild(box);
        row.appendChild(staticTimer);
        row.appendChild(resetBtnSecondary);
        row.appendChild(select);

        select.style.display = 'none';

        staticTimer.addEventListener('click', (e) => {
          if (staticTimer.classList.contains('active')) return;
          
          // Smite no es clickeable - solo referencia visual
          const currentSpell = select.value;
          if (SpellManager.isSmite(currentSpell)) return;
          
          startStaticTimer(staticTimer);
          row.classList.add('secondary-active');
          sendEvent({
            a: 'startSecondary',
            i: i,
            s: parseInt(staticTimer.dataset.seconds),
            startTime: staticTimer.startTime
          });
        });

        timerBoxes[i] = box;
        staticTimers[i] = staticTimer;
        spellSelects[i] = select;

        box.onclick = (e) => {
          if (e.target === message || e.target.closest('.time-shortcut')) return;
          
          if (box.classList.contains('active')) {
            // Efecto de pulsación en la caja del temporizador
            box.style.transform = 'scale(1.02)';
            setTimeout(() => {
              box.style.transform = '';
            }, 150);
            
            // Mostrar botones y reiniciar timeout
            showButtonsWithTimeout(box);
            return;
          }
          
          startTimer(box, true);
          // Mostrar botones al iniciar temporizador
          showButtonsWithTimeout(box);
        };
        
        // Mostrar botones al hacer hover solo si está activo
        box.addEventListener('mouseenter', () => {
          if (box.classList.contains('active')) {
            showButtonsWithTimeout(box);
          }
        });
        
        box.addEventListener('mouseleave', () => {
          // No hacer nada al salir del hover, el timeout se encarga
        });

        box.querySelectorAll('.time-shortcut').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const seconds = parseInt(e.target.dataset.sec);
            adjustTime(box, seconds, true);
          });
        });

        document.getElementById('timers').appendChild(row);
        console.log(`Timer ${i} (${role}) created and appended`);
      });
      console.log('All timers created successfully');
      
      gameTimerEl = document.getElementById('gameTimer');
      mainActionBtn = document.getElementById('mainActionBtn');

      mainActionBtn.addEventListener('click', () => {
        if (isGameStarted) {
          resetAll();
        } else {
          startGameTimer();
          mainActionBtn.textContent = 'Reset All';
        }
      });

      // Definir toggleTutorial antes de usarlo
      function toggleTutorial() {
        const box = document.getElementById('tutorialBox');
        const arrow = document.getElementById('tutorialArrow');
        
        if (box.classList.contains('show')) {
          box.classList.remove('show');
          arrow.textContent = '▼';
        } else {
          box.classList.add('show');
          arrow.textContent = '▲';
        }
      }
      
      document.getElementById('toggleSpellsBtn').addEventListener('click', toggleSpells);
      document.getElementById('tutorialToggle').addEventListener('click', toggleTutorial);

      setupSyncPanel();
      if (!isSoloMode) {
        initPeer();
        
        // Inicializar host si corresponde (después de crear la sala)
        if (isHost) {
          // Esperar a que peer esté listo antes de inicializar como host
          if (peer && peer.open) {
            initializeHost();
          } else {
            peer.on('open', () => {
              initializeHost();
            });
          }
        }
      } else if (isHost) {
        // En modo solo, inicializar sin peer
        initializeHost();
      }
      
      updateTexts();
      
      // Inicializar AudioManager
      AudioManager.init();
      AudioManager.setupAutoResume();
      
      // Funciones auxiliares
      function promoteToHost() {
        if (isHost) return;
        
        isHost = true;
        shortId = generateShortId();
        hostNickname = sanitizeNickname(userNickname);
        
        setupSyncPanel();
        initPeer();
        
        setTimeout(() => {
          updatePlayersBar();
        }, 1000);
      }
      
      function connectToSecondaryHost() {
      // Conectar igual que al host original
      const hostIdInput = document.getElementById('hostIdInput');
      if (hostIdInput) {
        hostIdInput.value = secondaryHostBackupId;
      }
      connectToHost(); // Usar la función original de conexión
    }
    
    function tryConnectToBackupHosts() {
      const backupIds = Array.from(playerBackupIds.values());
      let attemptIndex = 0;
      
      const tryNext = () => {
        if (attemptIndex >= backupIds.length) {
          // Si no se puede conectar a ningún backup, convertirse en host
          isHost = true;
          shortId = myBackupId;
          hostNickname = sanitizeNickname(userNickname);
          
          // Mantener conexiones P2P existentes y reconfigurarlas como host
          connections = Array.from(peerConnections.values()).filter(conn => conn.open);
          
          // Reconfigurar cada conexión para que tenga los listeners de host
          connections.forEach(conn => {
            // Remover listeners P2P existentes
            conn.removeAllListeners('data');
            
            // Configurar listener de host (idéntico a setupConnection)
            conn.on('data', (data) => {
              if (!validateEventData(data)) return;
              
              if (data.a === 'playerInfo') {
                const sanitizedNick = sanitizeNickname(data.nick);
                const existingPlayer = connectedPlayers.get(data.from);
                let hasChanged = false;
                
                if (!existingPlayer) {
                  connectedPlayers.set(data.from, { nick: sanitizedNick, lastPong: Date.now(), champion: data.champion, color: data.color });
                  hasChanged = true;
                } else {
                  if (existingPlayer.nick !== sanitizedNick) {
                    existingPlayer.nick = sanitizedNick;
                    hasChanged = true;
                  }
                  if (existingPlayer.champion !== data.champion) {
                    existingPlayer.champion = data.champion;
                    hasChanged = true;
                  }
                  if (existingPlayer.color !== data.color) {
                    existingPlayer.color = data.color;
                    hasChanged = true;
                  }
                  existingPlayer.lastPong = Date.now();
                }
                
                if (hasChanged) {
                  updatePlayersBar();
                  // Retransmitir a todos los otros invitados
                  connections.forEach(otherConn => {
                    if (otherConn !== conn && otherConn.open) {
                      try {
                        otherConn.send({ a: 'playerUpdate', playerId: data.from, nick: sanitizedNick, champion: data.champion, color: data.color });
                      } catch (e) {}
                    }
                  });
                }
              } else {
                // Manejar otros eventos y retransmitir
                if (['start', 'reset', 'adjust', 'startSecondary', 'resetSecondary', 'changeSpell', 'startGame', 'resetAll', 'unleashedTeleport', 'secondaryHostDesignated', 'secondaryHostIdUpdate'].includes(data.a)) {
                  connections.forEach(otherConn => {
                    if (otherConn !== conn && otherConn.open) {
                      try {
                        otherConn.send(data);
                      } catch (e) {}
                    }
                  });
                }
              }
              handleSync(data);
            });
          });
          
          connectedPlayers.clear();
          connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
          
          // Designar host secundario si hay otros jugadores
          const remainingGuests = Array.from(peerConnections.keys()).filter(id => peerConnections.get(id).open);
          if (remainingGuests.length > 0) {
            secondaryHostId = remainingGuests[0];
            secondaryHostBackupId = playerBackupIds.get(secondaryHostId) || generateShortId();
            
            sendEvent({
              a: 'secondaryHostDesignated',
              secondaryHostId: secondaryHostId,
              joinOrder: remainingGuests
            });
          }
          
          setupSyncPanel();
          initPeer();
          updatePlayersBar();
          return;
        }
        
        const backupId = backupIds[attemptIndex];
        const testConnection = peer.connect(`${backupId}_host`);
        
        const timeout = setTimeout(() => {
          testConnection.close();
          attemptIndex++;
          setTimeout(tryNext, 500);
        }, 3000);
        
        testConnection.on('open', () => {
          clearTimeout(timeout);
          myConnection = testConnection;
          myConnection.send({ a: 'hello', nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor, from: myPeerId });
          
          heartbeatInterval = setInterval(() => {
            if (myConnection && myConnection.open) {
              myConnection.send({ a: 'heartbeat', from: myPeerId });
            }
          }, 2000);
          
          myConnection.on('data', (data) => {
            if (!validateEventData(data)) return;
            
            if (data.a === 'hostInfo') {
              hostNickname = sanitizeNickname(data.nick);
              const trans = LocalizationManager.getTranslations();
              document.getElementById('clientStatus').innerHTML = `
                <span>✅ ${trans.connected} <strong>${escapeHtml(hostNickname)}</strong></span>
                <span class="user-nick">${sanitizeNickname(userNickname)}</span>
              `;
              updatePlayersBar();
            } else if (data.a === 'playerList') {
              const list = new Map(data.players);
              connectedPlayers.clear();
              connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
              list.forEach((value, key) => {
                if (key !== myPeerId) {
                  connectedPlayers.set(key, { ...value, nick: sanitizeNickname(value.nick), lastPong: Date.now() });
                }
              });
              updatePlayersBar();
            } else if (data.a === 'peerList') {
              data.peers.forEach(peerId => {
                if (!peerConnections.has(peerId)) {
                  const peerConn = peer.connect(peerId);
                  peerConn.on('open', () => {
                    peerConnections.set(peerId, peerConn);
                    peerConn.send({ a: 'hello', from: myPeerId, nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor });
                    
                    peerConn.on('data', (peerData) => {
                      if (peerData.a === 'hello') {
                        connectedPlayers.set(peerData.from, { nick: sanitizeNickname(peerData.nick), champion: peerData.champion, color: peerData.color, lastPong: Date.now() });
                        updatePlayersBar();
                      } else {
                        handleSync(peerData);
                      }
                    });
                    
                    peerConn.on('close', () => {
                      peerConnections.delete(peerId);
                      connectedPlayers.delete(peerId);
                      updatePlayersBar();
                    });
                  });
                }
              });
            } else if (data.a === 'heartbeat') {
              if (myConnection && myConnection.open) {
                myConnection.send({ a: 'heartbeatAck', from: myPeerId });
              }
            } else if (data.a === 'fullState') {
              applyFullState(data.state);
            }
            
            handleSync(data);
          });
          
          myConnection.on('close', () => {
            if (heartbeatInterval) clearInterval(heartbeatInterval);
            myConnection = null;
          });
        });
        
        testConnection.on('error', () => {
          clearTimeout(timeout);
          attemptIndex++;
          setTimeout(tryNext, 500);
        });
      };
      
      tryNext();
    }
    
    function connectToNewHost(newHostId) {
      connectedPlayers.clear();
      connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
      
      const clientStatus = document.getElementById('clientStatus');
      if (clientStatus) {
        clientStatus.innerHTML = `
          <span class="error">❌ Connection Lost. Playing solo.</span>
          <span class="user-nick">${sanitizeNickname(userNickname)}</span>
        `;
      }
      
      updatePlayersBar();
    }


    
    });

    // Exponer funciones globales
    window.updateTexts = updateTexts;
    window.copyId = copyId;
    window.generateInviteLink = generateInviteLink;
    window.pasteId = pasteId;
    window.connectToHost = connectToHost;
    window.showToast = showToast;
  </script>

  <!-- Temporizador de partida y botón combinado -->
  <div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-top: 16px;">
    <span class="game-timer" id="gameTimer">10:00</span>
    <button class="main-action-btn" id="mainActionBtn">Start Game</button>
  </div>

  <div class="version-footer">
    Lol Spell Tracker v0.9.0 - 12/9/25 - Invite URL Testing - Share rooms with invite links
  </div>

  <div id="secondary-host-info" style="font-size: 0.7rem; color: #888; text-align: center; margin-top: 5px;"></div>

  <button class="tutorial-toggle" id="tutorialToggle">
    <span id="tutorialArrow">▼</span>
    <span>Tutorial</span>
  </button>
  
  <div class="tutorial-box" id="tutorialBox">
    <!-- Dinámico -->
  </div>
</body>
</html>
