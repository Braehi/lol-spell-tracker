<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LoL Spell Tracker</title>
  <link rel="icon" href="./images/Flash.png" type="image/png" />
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    :root {
      --bg-primary: #0a0a0a;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #2a2a2a;
      --bg-card: #1e1e1e;
      --bg-card-hover: #2a2a2a;
      --bg-card-selected: #2d2d44;
      --accent-primary: #bb86fc;
      --accent-secondary: #03dac6;
      --text-primary: #ffffff;
      --text-secondary: #e0e0e0;
      --text-muted: #aaa;
      --border: #333;
      --border-focus: #bb86fc;
      --error: #ff5252;
      --success: #4caf50;
      --warning: #ff9800;
      --shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
      --shadow-hover: 0 6px 16px rgba(187, 134, 252, 0.3);
      --radius: 8px;
      --radius-large: 14px;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      
      /* Timer specific colors */
      --time-color: #cf6679;
      --time-highlight: #ffffff;
      --ready-border: #3f8efc;
      --active-border: #ffeb3b;
      --warning-border: #e53935;
      --complete-border: #4caf50;
      --shadow-active: 0 0 12px rgba(255, 235, 59, 0.6);
      --reset-btn-bg: #e53935;
      --reset-btn-text: #ffffff;
      --reset-flash-border: #3f8efc;
      --btn-shortcut-bg: #3c3c3c;
      --btn-shortcut-border: #555;
      --btn-shortcut-text: #ffffff;
      --btn-shortcut-hover: #666;
      --notif-bg: rgba(0, 0, 0, 0.7);
      --feedback-color: #ffeb3b;
      --dropdown-bg: #2a2a2a;
      --dropdown-border: #555;
      --secondary-reset-bg: #3f8efc;
      --secondary-reset-hover: #66b0ff;
      --action-btn-bg: rgba(255, 255, 255, 0.05);
      --action-btn-hover: rgba(255, 255, 255, 0.1);
      --action-btn-text: #aaa;
      --action-btn-text-hover: #fff;
      --switch-bg: #3f8efc;
    }

    body.light-theme {
      --bg-primary: #f5f5f5;
      --bg-secondary: #ffffff;
      --bg-tertiary: #e0e0e0;
      --bg-card: #ffffff;
      --bg-card-hover: #f0f0f0;
      --bg-card-selected: #e3f2fd;
      --accent-primary: #6200ea;
      --accent-secondary: #00bcd4;
      --text-primary: #212121;
      --text-secondary: #424242;
      --text-muted: #757575;
      --border: #e0e0e0;
      --border-focus: #6200ea;
      --shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      --shadow-hover: 0 6px 16px rgba(98, 0, 234, 0.2);
      background: var(--bg-primary);
      --time-color: #d81b60;
      --time-highlight: #212121;
      --ready-border: #2196f3;
      --active-border: #ff9800;
      --warning-border: #f44336;
      --complete-border: #4caf50;
      --shadow-active: 0 0 12px rgba(255, 152, 0, 0.4);
      --reset-btn-bg: #f44336;
      --btn-shortcut-bg: #f5f5f5;
      --btn-shortcut-border: #bdbdbd;
      --btn-shortcut-text: #424242;
      --btn-shortcut-hover: #e0e0e0;
      --notif-bg: rgba(255, 255, 255, 0.9);
      --feedback-color: #ff9800;
      --dropdown-bg: #ffffff;
      --dropdown-border: #bdbdbd;
      --secondary-reset-bg: #2196f3;
      --secondary-reset-hover: #1976d2;
      --action-btn-bg: rgba(0, 0, 0, 0.05);
      --action-btn-hover: rgba(0, 0, 0, 0.1);
      --action-btn-text: #757575;
      --action-btn-text-hover: #212121;
    }

    body.light-theme .sync-panel input {
      background: #f5f5f5;
      color: #212121;
      border-color: #bdbdbd;
    }

    body.light-theme .sync-panel button {
      background: #e1bee7;
      color: #4a148c;
      border-color: #e1bee7;
    }

    body.light-theme .sync-panel button#pasteBtn {
      background: #bbdefb;
      color: #0d47a1;
      border-color: #bbdefb;
    }

    body.light-theme #players-bar {
      background: rgba(33, 150, 243, 0.15);
      border-color: rgba(33, 150, 243, 0.3);
      color: #424242;
    }

    body.light-theme .sync-panel .user-nick {
      color: #424242;
      opacity: 1;
    }

    * { 
      box-sizing: border-box;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    body {
      font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, var(--bg-primary) 0%, #1a1a2e 100%);
      color: var(--text-secondary);
      margin: 0;
      padding: 20px;
      text-align: center;
      gap: 16px;
      overflow-x: hidden;
    }

    body.diana-mode {
      background: linear-gradient(135deg, rgba(10, 10, 10, 0.8) 0%, rgba(26, 26, 46, 0.8) 100%), url('./Champions_assets/Diana_0.jpg');
      background-size: cover;
      background-position: center;
      background-attachment: fixed;
    }

    .controls-top {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 24px;
      margin-bottom: 10px;
      width: 100%;
      max-width: 380px;
    }

    .switch-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 20px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #555;
      transition: 0.3s;
      border-radius: 20px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    input:checked + .slider { background-color: var(--switch-bg); }
    input:checked + .slider:before { transform: translateX(22px); }

    h1 {
      text-align: center;
      font-size: 1.5rem;
      color: var(--accent);
      margin: 10px 0 20px;
      width: 100%;
      max-width: 380px;
    }

    #players-bar {
      width: 100%;
      max-width: 380px;
      font-size: 0.8rem;
      color: #aaa;
      text-align: center;
      margin: -8px 0 12px 0;
      padding: 6px 12px;
      border-radius: 6px;
      background: rgba(95, 142, 252, 0.1);
      border: 1px solid rgba(95, 142, 252, 0.2);
      white-space: normal;
      min-height: 1.2em;
      line-height: 1.4;
    }

    .toggle-row {
      width: 100%;
      max-width: 380px;
      display: flex;
      justify-content: flex-end;
      margin-bottom: 0px;
    }

    .toggle-spells-btn {
      font-size: 0.85rem;
      color: #aaa;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #444;
      border-radius: 6px;
      padding: 4px 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      transition: all 0.2s ease;
      transform: translateX(-24px);
    }

    .toggle-spells-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--accent);
      border-color: var(--accent);
    }

    .timer-row {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      max-width: 380px;
      margin-bottom: 6px;
      position: relative;
    }

    .reset-btn {
      width: 28px;
      height: 28px;
      background: var(--reset-btn-bg);
      color: var(--reset-btn-text);
      border: none;
      border-radius: 6px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    }

    .timer-row.active .reset-btn {
      opacity: 1;
      visibility: visible;
    }

    .reset-btn:hover {
      background: #ff5252;
      transform: scale(1.1);
    }

    .role-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #333;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: transform 0.2s;
    }

    .role-icon img {
      width: 28px;
      height: 28px;
    }

    .timer-row:hover .role-icon {
      transform: scale(1.1);
    }

    .timer-box {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--bg-secondary);
      border: 2px solid var(--border);
      border-radius: 8px;
      padding: 6px 10px;
      width: calc(100% - 150px);
      min-width: 200px;
      box-shadow: var(--shadow);
      gap: 10px;
      cursor: pointer;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
      position: relative;
      overflow: hidden;
      height: 44px;
    }

    .timer-box:hover:not(.active) {
      border-color: var(--ready-border);
      box-shadow: var(--shadow-hover);
    }

    .timer-box.active {
      border-color: var(--active-border);
      animation: pulse-border 1.5s infinite, pop-in 0.3s ease-out;
      box-shadow: var(--shadow-active);
      background: rgba(255, 235, 59, 0.1);
    }

    .timer-box.completed {
      border-color: var(--complete-border) !important;
      box-shadow: 0 0 12px rgba(76, 175, 80, 0.6) !important;
      background: rgba(76, 175, 80, 0.1);
      animation: none;
    }

    @keyframes pulse-border {
      0% { border-color: var(--active-border); }
      50% { border-color: #ffd54f; }
      100% { border-color: var(--active-border); }
    }

    @keyframes pop-in {
      0% { transform: scale(0.9); opacity: 0.7; }
      70% { transform: scale(1.05); }
      100% { transform: scale(1); opacity: 1; }
    }

    .role-name {
      font-weight: bold;
      color: var(--text-secondary);
      font-size: 0.85rem;
      min-width: 50px;
      text-align: left;
    }

    .time-shortcut {
      opacity: 0;
      visibility: hidden;
      font-family: 'Courier New', monospace;
      font-size: 0.75rem;
      font-weight: bold;
      color: var(--btn-shortcut-text);
      background: var(--btn-shortcut-bg);
      border: 1px solid var(--btn-shortcut-border);
      border-radius: 4px;
      width: 28px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .timer-box.active .time-shortcut {
      opacity: 1;
      visibility: visible;
    }
    
    .timer-box.buttons-hidden .time-shortcut {
      opacity: 0;
      visibility: hidden;
    }

    .time-shortcut:hover {
      background: var(--btn-shortcut-hover);
    }
    
    .time-shortcut:active {
      transform: scale(0.9);
      background: var(--accent-primary);
    }

    .time {
      width: 50px;
      text-align: center;
      font-family: 'Courier New', monospace;
      font-size: 1.1rem;
      font-weight: bold;
      color: var(--time-color);
      transition: color 0.3s ease;
    }

    .timer-box.active .time {
      color: var(--active-border);
    }

    .timer-box.active .time.warning {
      color: var(--warning-border) !important;
    }

    .time.highlight {
      color: var(--time-highlight);
    }

    /* TEMPORIZADOR SECUNDARIO */
    .static-timer {
      width: 68px;
      height: 44px;
      font-family: 'Courier New', monospace;
      font-size: 1.1rem;
      font-weight: bold;
      color: #ffffff;
      background: var(--bg-secondary) center/cover no-repeat;
      border: 2px solid var(--border);
      border-radius: 8px;
      flex-shrink: 0;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      position: relative;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      padding-bottom: 4px;
      line-height: 1;
    }

    .static-timer::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(0deg, rgba(0,0,0,0.7), rgba(0,0,0,0.5));
      border-radius: 6px;
      pointer-events: none;
    }

    .static-timer span {
      position: relative;
      z-index: 1;
      text-shadow: 0 1px 2px rgba(0,0,0,0.9);
    }

    .static-timer:hover {
      border-color: var(--ready-border);
      box-shadow: var(--shadow-hover);
    }

    .static-timer.active {
      border-color: var(--active-border);
      animation: pulse-border 1.5s infinite, pop-in 0.3s ease-out;
      box-shadow: var(--shadow-active);
      background-color: rgba(255, 235, 59, 0.15);
    }

    .static-timer.warning {
      border-color: var(--warning-border);
      box-shadow: 0 0 12px rgba(229, 57, 53, 0.6);
      color: var(--warning-border);
    }

    /* Desplegable - con animaci√≥n suave */
    .spell-select {
      width: 68px;
      height: 44px;
      padding: 6px 8px;
      background: var(--dropdown-bg);
      color: var(--text);
      border: 1px solid var(--dropdown-border);
      border-radius: 8px;
      font-size: 0.8rem;
      font-family: inherit;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%226%22%3E%3Cpath%20d%3D%22M1%201l4%204%204-4%22%20stroke%3D%22%23888%22%20fill%3D%22none%22%20stroke-width%3D%221.5%22/%3E%3C%2Fsvg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 10px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      flex-shrink: 0;
      order: 3;
    }

    .spell-select:hover {
      border-color: var(--accent);
      background-color: #3a3a3a;
    }

    .spell-select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 8px rgba(187, 134, 252, 0.4);
    }

    /* Overlay de reinicio */
    .reset-message {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      font-weight: bold;
      border-radius: 8px;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
      z-index: 10;
    }

    .reset-message.show {
      opacity: 1;
    }

    .reset-flash {
      border-color: var(--reset-flash-border) !important;
      box-shadow: 0 0 10px rgba(63, 142, 252, 0.6) !important;
    }

    /* Feedback visual */
    .time-notification {
      position: absolute;
      top: -28px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--notif-bg);
      color: white;
      font-size: 0.8rem;
      font-family: 'Courier New', monospace;
      padding: 3px 8px;
      border-radius: 4px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s;
      z-index: 20;
    }

    .time-notification.show {
      opacity: 1;
      visibility: visible;
    }

    .feedback {
      position: absolute;
      bottom: -22px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--feedback-color);
      color: #000;
      font-size: 0.75rem;
      font-family: 'Courier New', monospace;
      padding: 2px 8px;
      border-radius: 4px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.15s;
      z-index: 20;
    }

    .feedback.show {
      opacity: 1;
      visibility: visible;
    }

    /* Bot√≥n de reinicio secundario */
    .reset-btn-secondary {
      width: 28px;
      height: 28px;
      background: var(--secondary-reset-bg);
      color: var(--reset-btn-text);
      border: none;
      border-radius: 6px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      order: 99;
    }

    .timer-row.secondary-active .reset-btn-secondary {
      opacity: 1;
      visibility: visible;
    }

    .reset-btn-secondary:hover {
      background: var(--secondary-reset-hover);
      transform: scale(1.1);
    }

    /* Bot√≥n combinado: Start Game / Reset All */
    .main-action-btn {
      padding: 6px 16px;
      background: var(--action-btn-bg);
      color: var(--action-btn-text);
      border: 1px solid #444;
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: normal;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      margin-top: -15px;
    }

    .main-action-btn:hover {
      background: var(--action-btn-hover);
      color: var(--action-btn-text-hover);
      border-color: var(--accent);
    }

    .main-action-btn:active {
      transform: scale(0.98);
      box-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
    }

    /* Temporizador de 10 minutos (sutil) */
    .game-timer {
      font-family: 'Courier New', monospace;
      font-size: 1.1rem;
      font-weight: bold;
      color: var(--accent);
      min-width: 60px;
      text-align: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
      transform: translateY(-5px);
    }

    .game-timer.active {
      opacity: 1;
      visibility: visible;
    }

    .version-footer {
      margin-top: 8px;
      margin-bottom: 6px;
      font-size: 0.75rem;
      color: var(--text);
      text-align: center;
      opacity: 0.6;
      letter-spacing: 0.5px;
      font-family: 'Courier New', monospace;
      width: 100%;
      max-width: 380px;
      padding: 6px 0;
      border-top: 1px solid var(--border);
      transition: opacity 0.3s, color 0.3s;
    }

    .tutorial-box {
      width: 100%;
      max-width: 380px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 0.78rem;
      color: var(--text);
      line-height: 1.5;
      text-align: left;
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
    }
    .tutorial-box.show {
      max-height: 200px;
      opacity: 1;
    }
    .tutorial-toggle {
      width: 100%;
      max-width: 380px;
      background: var(--action-btn-bg);
      color: var(--action-btn-text);
      border: 1px solid #444;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .tutorial-toggle:hover {
      background: var(--action-btn-hover);
      color: var(--action-btn-text-hover);
      border-color: var(--accent);
    }
    .tutorial-box strong {
      color: var(--accent);
    }
    .key-hint {
      display: inline-block;
      background: var(--btn-shortcut-bg);
      color: var(--btn-shortcut-text);
      border: 1px solid var(--btn-shortcut-border);
      border-radius: 4px;
      padding: 2px 6px;
      font-family: 'Courier New', monospace;
      font-size: 0.8rem;
      margin: 0 2px;
    }

    .sync-panel {
      width: 100%;
      max-width: 380px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 14px 16px;
      font-size: 0.85rem;
      margin-bottom: 2px;
      color: var(--text);
    }
    .sync-panel h3 {
      margin: 0 0 10px 0;
      font-size: 1.05rem;
      color: var(--accent);
    }
    .sync-panel .input-group {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 6px 0;
    }
    .sync-panel .status {
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-align: left;
    }
    .sync-panel .user-nick {
      font-size: 0.85rem;
      color: #bbb;
      opacity: 0.9;
    }
    .sync-panel input {
      flex: 1;
      padding: 8px 10px;
      border: 1px solid var(--btn-shortcut-border);
      border-radius: 6px;
      background: #333;
      color: white;
      font-family: monospace;
      font-size: 0.95rem;
      text-transform: uppercase;
    }
    .sync-panel button {
      padding: 8px 6px;
      background: var(--accent-primary);
      color: #000;
      border: 1px solid var(--accent-primary);
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      font-size: 0.8rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: all 0.2s ease;
    }
    .sync-panel button#pasteBtn {
      background: var(--secondary-reset-bg);
      border-color: var(--secondary-reset-bg);
      color: white;
    }
    .sync-panel button#pasteBtn:hover {
      background: var(--secondary-reset-hover);
      border-color: var(--secondary-reset-hover);
    }
    .sync-panel button:hover {
      opacity: 0.9;
      transform: translateY(-1px);
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
    }
    .sync-panel button:active {
      transform: translateY(0);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
  </style>
  
  <!-- Pre-carga de recursos -->
  <link rel="preload" href="./images/Bottom_icon.png" as="image">
  <link rel="preload" href="./images/Diana_0.jpg" as="image">
  <link rel="preload" href="./images/Diana.png" as="image">
  <link rel="preload" href="./images/Flash.png" as="image">
  <link rel="preload" href="./images/Jungle_icon.png" as="image">
  <link rel="preload" href="./images/Middle_icon.png" as="image">
  <link rel="preload" href="./images/SummonerBarrier.png" as="image">
  <link rel="preload" href="./images/SummonerBoost.png" as="image">
  <link rel="preload" href="./images/SummonerDot.png" as="image">
  <link rel="preload" href="./images/SummonerExhaust.png" as="image">
  <link rel="preload" href="./images/SummonerHaste.png" as="image">
  <link rel="preload" href="./images/SummonerHeal.png" as="image">
  <link rel="preload" href="./images/SummonerTeleport.png" as="image">
  <link rel="preload" href="./images/Support_icon.png" as="image">
  <link rel="preload" href="./images/Top_icon.png" as="image">
</head>
<body>
  <div class="controls-top">
    <div class="switch-container">
      <span>üåô</span>
      <label class="switch">
        <input type="checkbox" id="themeSwitch" />
        <span class="slider"></span>
      </label>
      <span>‚òÄÔ∏è</span>
    </div>
    <div class="switch-container">
      <span>üá¨üáß</span>
      <label class="switch">
        <input type="checkbox" id="langSwitch" />
        <span class="slider"></span>
      </label>
      <span>üá™üá∏</span>
    </div>
    <div class="switch-container">
      <span>üîá</span>
      <label class="switch">
        <input type="checkbox" id="soundSwitch" checked />
        <span class="slider"></span>
      </label>
      <span>üîä</span>
    </div>
  </div>

  <h1 id="appTitle">LoL Spell Tracker</h1>
  
  <div id="players-bar">
    <span id="players-list">Waiting for players...</span>
  </div>

  <div class="sync-panel" id="syncPanel">
    <!-- Din√°mico seg√∫n rol -->
  </div>

  <!-- Bot√≥n show/hide en su propia fila, encima de los temporizadores -->
  <div class="toggle-row">
    <button class="toggle-spells-btn" id="toggleSpellsBtn">
      <span id="toggleArrow">‚û°Ô∏è</span>
      <span id="toggleText">show</span>
    </button>
  </div>

  <div id="timers"></div>
  
  <div id="timer-error-msg" style="display: none; color: var(--warning); font-size: 0.8rem; margin-top: 8px; text-align: center; max-width: 380px;">
    <!-- Din√°mico -->
  </div>
  <script>
    // ====================== CONFIGURACI√ìN DESDE SESSIONSTORAGE ======================
    let launchConfig = {};
    try {
      launchConfig = JSON.parse(sessionStorage.getItem('lol-tracker-launch-config') || '{}');
      console.log('Loaded config:', launchConfig);
    } catch (e) {
      console.log('Error parsing launch config:', e);
    }
    
    const champions = ['Aatrox', 'Ahri', 'Akali', 'Akshan', 'Alistar', 'Ambessa', 'Amumu', 'Anivia', 'Annie', 'Aphelios', 'Ashe', 'Aurelion Sol', 'Aurora', 'Azir', 'Bard', 'Bel\'Veth', 'Blitzcrank', 'Brand', 'Braum', 'Briar', 'Caitlyn', 'Camille', 'Cassiopeia', 'Cho\'Gath', 'Corki', 'Darius', 'Diana', 'Dr. Mundo', 'Draven', 'Ekko', 'Elise', 'Evelynn', 'Ezreal', 'Fiddlesticks', 'Fiora', 'Fizz', 'Galio', 'Gangplank', 'Garen', 'Gnar', 'Gragas', 'Graves', 'Gwen', 'Hecarim', 'Heimerdinger', 'Hwei', 'Illaoi', 'Irelia', 'Ivern', 'Janna', 'Jarvan IV', 'Jax', 'Jayce', 'Jhin', 'Jinx', 'K\'Sante', 'Kai\'Sa', 'Kalista', 'Karma', 'Karthus', 'Kassadin', 'Katarina', 'Kayle', 'Kayn', 'Kennen', 'Kha\'Zix', 'Kindred', 'Kled', 'Kog\'Maw', 'LeBlanc', 'Lee Sin', 'Leona', 'Lillia', 'Lissandra', 'Lucian', 'Lulu', 'Lux', 'Malphite', 'Malzahar', 'Maokai', 'Master Yi', 'Mel', 'Milio', 'Miss Fortune', 'Mordekaiser', 'Morgana', 'Naafiri', 'Nami', 'Nasus', 'Nautilus', 'Neeko', 'Nidalee', 'Nilah', 'Nocturne', 'Nunu & Willump', 'Olaf', 'Orianna', 'Ornn', 'Pantheon', 'Poppy', 'Pyke', 'Qiyana', 'Quinn', 'Rakan', 'Rammus', 'Rek\'Sai', 'Rell', 'Renata Glasc', 'Renekton', 'Rengar', 'Riven', 'Rumble', 'Ryze', 'Samira', 'Sejuani', 'Senna', 'Seraphine', 'Sett', 'Shaco', 'Shen', 'Shyvana', 'Singed', 'Sion', 'Sivir', 'Skarner', 'Smolder', 'Sona', 'Soraka', 'Swain', 'Sylas', 'Syndra', 'Tahm Kench', 'Taliyah', 'Talon', 'Taric', 'Teemo', 'Thresh', 'Tristana', 'Trundle', 'Tryndamere', 'Twisted Fate', 'Twitch', 'Udyr', 'Urgot', 'Varus', 'Vayne', 'Veigar', 'Vel\'Koz', 'Vex', 'Vi', 'Viego', 'Viktor', 'Vladimir', 'Volibear', 'Warwick', 'Wukong', 'Xayah', 'Xerath', 'Xin Zhao', 'Yasuo', 'Yone', 'Yorick', 'Yuumi', 'Zac', 'Zed', 'Zeri', 'Ziggs', 'Zilean', 'Zoe', 'Zyra'];
    const userNickname = launchConfig.nick || champions[Math.floor(Math.random() * champions.length)];
    const userRole = launchConfig.role || 'join';
    const urlTheme = launchConfig.theme;
    const urlLang = launchConfig.lang;
    const dianaMode = launchConfig.diana === true;
    const userChampion = launchConfig.champion;
    const userColor = launchConfig.color;
    const isDianaMode = launchConfig.diana === true;

    let isHost = userRole === 'host';
    let isSoloMode = userRole === 'solo';
    
    // 1. Inicializar host si corresponde
    if (isHost) {
      initializeHost();
    }
    
    function getChampionFileName(championName) {
      // Special cases first
      const specialCases = {
        "Dr. Mundo": "Dr_Mundo",
        "Nunu": "Nunu_&_Willump"
      };
      
      if (specialCases[championName]) {
        return specialCases[championName];
      }
      
      // Keep straight apostrophes as they are in file names
      let fileName = championName
        .replace(/ /g, "_")   // spaces to underscores
        .replace(/\./g, "_"); // dots to underscores
      
      return fileName;
    }
    
    // Limpiar configuraci√≥n despu√©s de usar
    setTimeout(() => {
      sessionStorage.removeItem('lol-tracker-launch-config');
    }, 500);

    // Utilities and constants
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function sanitizeNickname(nick) {
      if (typeof nick !== 'string') return 'Player';
      return nick.replace(/[<>"'&]/g, '').trim() || 'Player';
    }

    function validateEventData(data) {
      if (!data || typeof data !== 'object') return false;
      if (typeof data.a !== 'string') return false;
      
      switch (data.a) {
        case 'start':
        case 'reset':
        case 'startSecondary':
        case 'resetSecondary':
          return typeof data.i === 'number' && data.i >= 0 && data.i < 5;
        case 'adjust':
          return typeof data.i === 'number' && data.i >= 0 && data.i < 5 &&
                 typeof data.s === 'number' && data.s >= -300 && data.s <= 300;
        case 'changeSpell':
          return typeof data.i === 'number' && data.i >= 0 && data.i < 5 &&
                 typeof data.spell === 'string' && spellData[data.spell];
        case 'hello':
          return typeof data.nick === 'string';
        default:
          return true;
      }
    }

    const DURATIONS = {
      PRIMARY: 300,     // 5:00
      GAME: 600,        // 10:00
      WARNING: 60,      // <= 60s
      NOTIF: 800,       // ms
      FEEDBACK: 500,    // ms
      RESET_FLASH: 1000 // ms
    };

    // ====================== GENERADOR DE ID ======================
    function generateShortId() {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let id = '';
      for (let i = 0; i < 6; i++) {
        id += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return id;
    }

    // ====================== TRADUCCIONES ======================
    const translations = {
      en: {
        waiting: 'Waiting for players...',
        generating: 'Generating new room...',
        invalidId: 'Invalid ID (6 characters)',
        connected: 'Connected to host',
        connecting: 'Connecting',
        error: 'Error',
        idInUse: 'ID in use. Click "New ID".',
        host: 'You are the host',
        tutorialTitle: 'Keyboard shortcuts:',
        keyStart: 'Start timer for role',
        keyAlt: 'Subtract 10 seconds (only if active and >10s left)',
        keyShift: 'Subtract 30 seconds (only if active and >30s left)',
        keyClick: 'Start timer',
        keyReset: 'Manual reset',
        reset: 'Reset',
        hostId: 'Host ID',
        copy: 'Copy',
        paste: 'Paste',
        join: 'Join',
        players: 'player',
        players_plural: 'players',
        noPlayers: 'No players',
        playingSolo: 'Playing solo',
        playingSoloHostLost: 'Playing solo (Host lost)'
      },
      es: {
        waiting: 'Esperando jugadores...',
        generating: 'Generando nueva sala...',
        invalidId: 'ID inv√°lida (6 caracteres)',
        connected: 'Conectado al anfitri√≥n',
        connecting: 'Conectando',
        error: 'Error',
        idInUse: 'ID en uso. Pulsa "Nueva ID".',
        host: 'Eres el host',
        tutorialTitle: 'Atajos de teclado:',
        keyStart: 'Inicia el temporizador del rol',
        keyAlt: 'Resta 10 segundos (solo si est√° activo y queda +10s)',
        keyShift: 'Resta 30 segundos (solo si est√° activo y queda +30s)',
        keyClick: 'Inicia el temporizador',
        keyReset: 'Reinicia manualmente',
        reset: 'Reinicio',
        hostId: 'ID del Host',
        copy: 'Copiar',
        paste: 'Pegar',
        join: 'Unirse',
        players: 'jugador',
        players_plural: 'jugadores',
        noPlayers: 'Sin jugadores',
        playingSolo: 'Jugando solo',
        playingSoloHostLost: 'Jugando solo (Host perdido)'
      }
    };

    let lang = 'en';
    if (urlLang) {
      lang = urlLang;
    } else {
      const browserLang = navigator.language || navigator.userLanguage;
      if (browserLang.startsWith('es')) {
        lang = 'es';
      }
    }

    // Cargar tema desde configuraci√≥n o localStorage
    const themeToUse = urlTheme || localStorage.getItem('lol-tracker-theme') || 'dark';
    if (themeToUse === 'light') {
      document.body.classList.add('light-theme');
    }

    // Configuraci√≥n inicial (se ejecutar√° en DOMContentLoaded)

    // ====================== VARIABLES GLOBALES ======================
    let shortId = generateShortId();
    let peer = null;
    let myPeerId = null;
    let connections = [];
    let myConnection = null;
    let heartbeatInterval = null;
    let hostLostTimeout = null;
    let playersBeforeDisconnect = new Map();
    let peerConnections = new Map();
    // HOST: Variables de control
    let myBackupId = null;
    let secondaryHostId = null;
    let secondaryHostBackupId = null;
    let hostBackupId = null;
    let joinOrder = []; // Para trackear orden de entrada
    let playerBackupIds = new Map();
    
    // ====================== INICIALIZACI√ìN HOST ======================
    function initializeHost() {
      // 1.2. Borrar informaci√≥n almacenada
      myBackupId = null;
      secondaryHostId = null;
      secondaryHostBackupId = null;
      hostBackupId = null;
      joinOrder = [];
      
      // 1.3. Generar backupID para el host
      myBackupId = generateShortId();
      
      // 1.4. Borrar lista de jugadores
      connectedPlayers.clear();
      
      // 1.5. Actualizar con informaci√≥n propia
      connectedPlayers.set(myPeerId, { 
        nick: sanitizeNickname(userNickname), 
        champion: userChampion, 
        color: userColor, 
        lastPong: Date.now(), 
        isSelf: true 
      });
      
      updatePlayersBar();
      
      // 1.7. Mostrar mensaje
      showToast(lang === 'es' ? 'üëë Eres el host.' : 'üëë You are the host.', 'info', 3000);
    }
    
    // ====================== RECONEXI√ìN CON REINTENTOS ======================
    function attemptReconnectionWithRetries() {
      let attempt = 1;
      const maxAttempts = 3;
      
      function tryReconnect() {
        if (attempt > maxAttempts) {
          // 6.3.6. Mensaje final de conexi√≥n perdida
          showToast(lang === 'es' ? '‚ùå Conexi√≥n perdida.' : '‚ùå Connection lost.', 'error', 0);
          return;
        }
        
        // 6.3. Mostrar mensaje de reconexi√≥n
        const message = attempt === 1 ? 
          (lang === 'es' ? 'üîÑ Reconectando...' : 'üîÑ Reconnecting...') :
          (lang === 'es' ? `üîÑ (${attempt})Reconectando...` : `üîÑ (${attempt})Reconnecting...`);
        
        showToast(message, 'info', 0);
        
        if (hostBackupId) {
          const testConnection = peer.connect(hostBackupId);
          
          const timeout = setTimeout(() => {
            testConnection.close();
            attempt++;
            setTimeout(tryReconnect, 100);
          }, 3000);
          
          testConnection.on('open', () => {
            clearTimeout(timeout);
            myConnection = testConnection;
            
            // 6.4. Conecta exitosamente - 6.5. Repetir punto 2
            myConnection.send({ a: 'playerInfo', nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor, from: myPeerId });
            
            myConnection.on('data', (data) => {
              handleSync(data);
            });
            
            myConnection.on('close', () => {
              attemptReconnectionWithRetries();
            });
          });
          
          testConnection.on('error', () => {
            clearTimeout(timeout);
            attempt++;
            setTimeout(tryReconnect, 100);
          });
        } else {
          attempt++;
          setTimeout(tryReconnect, 100);
        }
      }
      
      tryReconnect();
    }
    // joinOrder removed - derived from connectedPlayers
    let hostNickname = null;
    let hadHostConnection = false;

    const connectedPlayers = new Map();
    const pendingPings = new Map();

    let pingInterval = null;
    let cleanupInterval = null;

    // Spells disponibles
    const spellData = {
      heal: { duration: 240, icon: './images/SummonerHeal.png' },
      teleport: { duration: 300, icon: './images/SummonerTeleport.png' },
      ignite: { duration: 180, icon: './images/SummonerDot.png' },
      exhaust: { duration: 210, icon: './images/SummonerExhaust.png' },
      cleanse: { duration: 210, icon: './images/SummonerBoost.png' },
      ghost: { duration: 180, icon: './images/SummonerHaste.png' },
      barrier: { duration: 210, icon: './images/SummonerBarrier.png' }
    };

    const roles = ['Top', 'Jungle', 'Middle', 'Bottom', 'Support'];
    const icons = [
      "./images/Top_icon.png",
      "./images/Jungle_icon.png",
      "./images/Middle_icon.png",
      "./images/Bottom_icon.png",
      "./images/Support_icon.png"
    ];
    const defaultSpells = ['teleport', 'ignite', 'teleport', 'barrier', 'heal'];
    const keyMap = { '1': 0, '2': 1, '3': 2, '4': 3, '5': 4 };
    let timerBoxes = [];
    let staticTimers = [];
    let spellSelects = [];
    let autoHideTimeout = null;
    let gameTimerInterval = null;
    let isGameStarted = false;
    let isTeleportUnleashed = false;

    // Declarar gameTimerEl y mainActionBtn (asignar√°n despu√©s)
    let gameTimerEl, mainActionBtn;

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }


    // ====================== FUNCI√ìN PARA MOSTRAR BOTONES ======================
    function showButtonsWithTimeout(box) {
      box.classList.remove('buttons-hidden');
      if (box.hoverTimeout) {
        clearTimeout(box.hoverTimeout);
      }
      box.hoverTimeout = setTimeout(() => {
        if (box.classList.contains('active')) {
          box.classList.add('buttons-hidden');
        }
      }, 10000);
    }

    // ====================== FUNCIONES PRINCIPALES ======================
    function startTimer(box, shouldSync = true) {
      if (box.interval) return;
      const timeSpan = box.querySelector('.time');
      const row = box.parentElement;

      box.classList.remove('active', 'completed');
      row.classList.add('active');
      box.offsetHeight;
      box.classList.add('active');

      box.style.removeProperty('border-color');
      box.style.removeProperty('box-shadow');
      box.style.removeProperty('animation');

      let totalSeconds = parseInt(box.dataset.seconds) || DURATIONS.PRIMARY;
      box.startTime = new Date().getTime();
      box.dataset.seconds = totalSeconds;
      timeSpan.textContent = formatTime(totalSeconds);

      box.interval = setInterval(() => {
        totalSeconds = parseInt(box.dataset.seconds);
        totalSeconds--;
        box.dataset.seconds = totalSeconds;
        timeSpan.textContent = formatTime(totalSeconds);

        if (totalSeconds <= 0) {
          clearInterval(box.interval);
          box.interval = null;
          box.startTime = null;
          box.classList.remove('active');
          row.classList.remove('active');
          box.classList.add('completed');
          box.style.removeProperty('border-color');
          box.style.removeProperty('box-shadow');
          box.dataset.seconds = DURATIONS.PRIMARY;
          timeSpan.textContent = '05:00';
          timeSpan.style.color = '';
          timeSpan.classList.remove('warning');
          playPingSound();

          setTimeout(() => {
            if (!box.interval) {
              box.classList.remove('completed');
            }
          }, 10000);
        } else if (totalSeconds <= 60) {
          box.style.animation = 'none';
          box.style.borderColor = 'var(--warning-border)';
          box.style.boxShadow = '0 0 12px rgba(229, 57, 53, 0.6)';
          timeSpan.classList.add('warning');
        } else {
          box.style.removeProperty('animation');
          box.style.removeProperty('border-color');
          box.style.removeProperty('box-shadow');
          box.classList.add('active');
          timeSpan.classList.remove('warning');
        }
      }, 1000);

      if (shouldSync) {
        sendEvent({
          a: 'start',
          i: parseInt(box.dataset.index),
          s: totalSeconds,
          startTime: box.startTime
        });
      }
      
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      checkTimerErrors(minutes, seconds);
    }

    function resetTimer(box, shouldSync = true) {
      const timeSpan = box.querySelector('.time');
      const message = box.querySelector('.reset-message');
      const row = box.parentElement;

      if (box.interval) {
        clearInterval(box.interval);
        box.interval = null;
      }

      timeSpan.textContent = '05:00';
      timeSpan.style.color = '';
      timeSpan.classList.remove('warning');
      box.classList.remove('active', 'completed', 'buttons-hidden');
      row.classList.remove('active');
      if (box.hoverTimeout) {
        clearTimeout(box.hoverTimeout);
        box.hoverTimeout = null;
      }
      box.style.removeProperty('border-color');
      box.style.removeProperty('box-shadow');
      box.style.removeProperty('animation');
      box.dataset.seconds = 300;

      message.classList.add('show');
      box.classList.add('reset-flash');
      setTimeout(() => {
        message.classList.remove('show');
        box.classList.remove('reset-flash');
      }, DURATIONS.RESET_FLASH);

      if (shouldSync) {
        sendEvent({
          a: 'reset',
          i: parseInt(box.dataset.index)
        });
      }
    }

    function adjustTime(box, seconds, shouldSync = true) {
      const timeSpan = box.querySelector('.time');
      const notification = box.querySelector('.time-notification');
      const feedback = box.querySelector('.feedback');

      if (!box.classList.contains('active')) return;

      const currentTotal = parseInt(box.dataset.seconds) || DURATIONS.PRIMARY;

      if (seconds === -10 && currentTotal < 10) return;
      if (seconds === -30 && currentTotal < 30) return;

      const newTotal = Math.max(0, currentTotal + seconds);
      box.dataset.seconds = newTotal;
      timeSpan.textContent = formatTime(newTotal);

      notification.textContent = `${seconds}s`;
      notification.classList.add('show');
      setTimeout(() => notification.classList.remove('show'), DURATIONS.NOTIF);

      feedback.textContent = seconds === -10 ? '-10' : '-30';
      feedback.classList.add('show');
      setTimeout(() => feedback.classList.remove('show'), DURATIONS.FEEDBACK);

      timeSpan.style.color = 'white';
      timeSpan.style.transform = 'scale(0.9)';
      setTimeout(() => {
        timeSpan.style.color = '';
        timeSpan.style.transform = '';
      }, 150);
      
      timeSpan.classList.add('highlight');
      setTimeout(() => timeSpan.classList.remove('highlight'), DURATIONS.FEEDBACK);

      if (shouldSync) {
        sendEvent({
          a: 'adjust',
          i: parseInt(box.dataset.index),
          s: seconds
        });
      }
    }

    // ====================== TEMPORIZADORES SECUNDARIOS ======================
    function startStaticTimer(el) {
      if (el.interval) return;
      const timeSpan = el.querySelector('span');
      const row = el.parentElement;

      el.classList.remove('completed');
      el.classList.add('active');

      el.style.removeProperty('border-color');
      el.style.removeProperty('box-shadow');
      el.style.removeProperty('animation');

      let totalSeconds = parseInt(el.dataset.seconds);
      el.startTime = new Date().getTime();
      timeSpan.textContent = formatTime(totalSeconds);

      el.interval = setInterval(() => {
        totalSeconds--;
        el.dataset.seconds = totalSeconds;
        timeSpan.textContent = formatTime(totalSeconds);

        if (totalSeconds <= 0) {
          clearInterval(el.interval);
          el.interval = null;
          el.startTime = null;
          el.classList.remove('active');
          row.classList.remove('secondary-active');
          el.classList.add('completed');
          el.style.removeProperty('border-color');
          el.style.removeProperty('box-shadow');
          el.dataset.seconds = parseInt(el.dataset.initialDuration);
          timeSpan.textContent = formatTime(el.dataset.seconds);
        } else if (totalSeconds <= 60) {
          el.style.animation = 'none';
          el.style.borderColor = 'var(--warning-border)';
          el.style.boxShadow = '0 0 12px rgba(229, 57, 53, 0.6)';
        } else {
          el.style.removeProperty('animation');
          el.style.removeProperty('border-color');
          el.style.removeProperty('box-shadow');
          el.classList.add('active');
        }
      }, 1000);
    }

    function resetStaticTimer(el, select) {
      const timeSpan = el.querySelector('span');
      const row = el.parentElement;

      if (el.interval) {
        clearInterval(el.interval);
        el.interval = null;
      }

      const spell = select.value;
      const data = spellData[spell];
      let duration = data.duration;
      
      if (spell === 'teleport' && isTeleportUnleashed) {
        duration = 240;
      }
      
      el.dataset.seconds = duration;
      el.dataset.initialDuration = duration;
      timeSpan.textContent = formatTime(duration);

      el.classList.remove('active', 'completed');
      row.classList.remove('secondary-active');
      el.style.removeProperty('border-color');
      el.style.removeProperty('box-shadow');
      el.style.removeProperty('animation');

      const message = document.createElement('div');
      message.className = 'reset-message';
      message.textContent = 'Reset';
      el.appendChild(message);
      message.classList.add('show');
      setTimeout(() => {
        if (message.parentNode) message.remove();
      }, DURATIONS.RESET_FLASH);
    }

    function updateStaticTimerStyle(el) {
      const seconds = parseInt(el.dataset.seconds);
      el.classList.remove('warning', 'active');
      if (seconds <= 60 && seconds > 0) {
        el.classList.add('warning');
      }
    }

    let errorTimeout = null;
    
    function checkTimerErrors(startTimeMinutes, startTimeSeconds) {
      const totalSeconds = startTimeMinutes * 60 + startTimeSeconds;
      const errorMsg = document.getElementById('timer-error-msg');
      
      if (totalSeconds > 301) {
        errorMsg.textContent = lang === 'es' ? '¬øTemporizadores incorrectos? Comprueba la hora del sistema.' : 'Wrong timers? Check system time.';
        errorMsg.style.display = 'block';
        
        if (errorTimeout) clearTimeout(errorTimeout);
        errorTimeout = setTimeout(() => {
          errorMsg.style.display = 'none';
        }, 60000);
      } else {
        errorMsg.style.display = 'none';
        if (errorTimeout) {
          clearTimeout(errorTimeout);
          errorTimeout = null;
        }
      }
    }

    // ====================== TOGGLE + AUTO-HIDE ======================
    function toggleSpells() {
      const btn = document.getElementById('toggleSpellsBtn');
      const arrow = document.getElementById('toggleArrow');
      const text = document.getElementById('toggleText');
      const isShowing = arrow.textContent.trim() === '‚¨ÖÔ∏è';

      if (autoHideTimeout) {
        clearTimeout(autoHideTimeout);
        autoHideTimeout = null;
      }

      if (isShowing) {
        spellSelects.forEach(el => el.style.display = 'none');
        staticTimers.forEach(el => el.style.display = 'flex');
        document.querySelectorAll('.reset-btn-secondary').forEach(btn => btn.style.display = 'flex');
        document.querySelectorAll('.timer-box').forEach(box => box.style.transform = '');
        document.querySelectorAll('.role-icon').forEach((icon, i) => {
          icon.style.transform = '';
          const img = icon.querySelector('img');
          img.src = icons[i];
        });
        arrow.textContent = '‚û°Ô∏è';
        text.textContent = 'show';
      } else {
        spellSelects.forEach(el => el.style.display = 'block');
        staticTimers.forEach(el => el.style.display = 'none');
        document.querySelectorAll('.reset-btn-secondary').forEach(btn => btn.style.display = 'none');
        document.querySelectorAll('.timer-box').forEach(box => box.style.transform = 'translateX(-15px)');
        document.querySelectorAll('.role-icon').forEach((icon, i) => {
          icon.style.transform = 'translateX(-15px)';
          const img = icon.querySelector('img');
          const spell = spellSelects[i].value;
          img.src = spellData[spell].icon;
        });
        arrow.textContent = '‚¨ÖÔ∏è';
        text.textContent = 'hide';

        autoHideTimeout = setTimeout(() => {
          spellSelects.forEach(el => el.style.display = 'none');
          staticTimers.forEach(el => el.style.display = 'flex');
          document.querySelectorAll('.reset-btn-secondary').forEach(btn => btn.style.display = 'flex');
          document.querySelectorAll('.timer-box').forEach(box => box.style.transform = '');
          document.querySelectorAll('.role-icon').forEach((icon, i) => {
            icon.style.transform = '';
            const img = icon.querySelector('img');
            img.src = icons[i];
          });
          arrow.textContent = '‚û°Ô∏è';
          text.textContent = 'show';
          autoHideTimeout = null;
        }, 30000);
      }
    }

    // ====================== GAME TIMER (10 minutos) ======================
    function startGameTimer() {
      if (gameTimerInterval) {
        clearInterval(gameTimerInterval);
        gameTimerInterval = null;
      }

      let totalSeconds = DURATIONS.GAME;
      gameTimerEl.textContent = formatTime(totalSeconds);
      gameTimerEl.classList.add('active');

      gameTimerInterval = setInterval(() => {
        totalSeconds--;
        gameTimerEl.textContent = formatTime(totalSeconds);

        if (totalSeconds <= 0) {
          clearInterval(gameTimerInterval);
          gameTimerInterval = null;
          gameTimerEl.textContent = 'Unleashed Teleport!';
          updateTeleportDuration(240);
          sendEvent({ a: 'unleashedTeleport' });
        }
      }, 1000);

      sendEvent({ a: 'startGame' });
      isGameStarted = true;
    }

    function resetAll(shouldSync = true) {
      if (shouldSync) {
        sendEvent({ a: 'resetAll' });
      }

      timerBoxes.forEach(box => {
        if (box.interval) {
          clearInterval(box.interval);
          box.interval = null;
        }
        const timeSpan = box.querySelector('.time');
        const message = box.querySelector('.reset-message');
        const row = box.parentElement;

        timeSpan.textContent = '05:00';
        timeSpan.style.color = '';
        timeSpan.classList.remove('warning');
        box.classList.remove('active', 'completed');
        row.classList.remove('active');
        box.style.removeProperty('border-color');
        box.style.removeProperty('box-shadow');
        box.style.removeProperty('animation');
        box.dataset.seconds = 300;

        message.classList.add('show');
        box.classList.add('reset-flash');
        setTimeout(() => {
          message.classList.remove('show');
          box.classList.remove('reset-flash');
        }, 1000);
      });

      staticTimers.forEach((el, i) => {
        if (el.interval) {
          clearInterval(el.interval);
          el.interval = null;
        }
        const timeSpan = el.querySelector('span');
        const row = el.parentElement;
        const select = spellSelects[i];

        const defaultSpell = defaultSpells[i];
        select.value = defaultSpell;
        const data = spellData[defaultSpell];
        el.dataset.seconds = data.duration;
        el.dataset.initialDuration = data.duration;
        timeSpan.textContent = formatTime(data.duration);
        el.style.backgroundImage = `url(${data.icon})`;

        el.classList.remove('active', 'completed');
        row.classList.remove('secondary-active');
        el.style.removeProperty('border-color');
        el.style.removeProperty('box-shadow');
        el.style.removeProperty('animation');

        const message = document.createElement('div');
        message.className = 'reset-message';
        message.textContent = 'Reset';
        el.appendChild(message);
        message.classList.add('show');
        setTimeout(() => {
          if (message.parentNode) message.remove();
        }, 1000);
      });

      if (gameTimerInterval) {
        clearInterval(gameTimerInterval);
        gameTimerInterval = null;
      }

      gameTimerEl.classList.remove('active');
      gameTimerEl.textContent = '10:00';
      isTeleportUnleashed = false;
      updateTeleportDuration(300);

      mainActionBtn.textContent = 'Start Game';
      isGameStarted = false;
      
      const errorMsg = document.getElementById('timer-error-msg');
      errorMsg.style.display = 'none';
      if (errorTimeout) {
        clearTimeout(errorTimeout);
        errorTimeout = null;
      }
    }

    // ====================== SONIDO ======================
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    function playPingSound() {
      if (audioContext.state === 'suspended') return;
      if (!soundEnabled()) return;

      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.type = 'square';
      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.15);
    }

    function soundEnabled() {
      return soundSwitch.checked;
    }

    document.addEventListener('click', () => {
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
    }, { once: true });

    // ====================== CAMBIO DE IDIOMA ======================
    const langSwitch = document.getElementById('langSwitch');
    const soundSwitch = document.getElementById('soundSwitch');

    langSwitch.addEventListener('change', () => {
      lang = langSwitch.checked ? 'es' : 'en';
      localStorage.setItem('lol-tracker-lang', lang);
      updateTexts();
      
      const errorMsg = document.getElementById('timer-error-msg');
      if (errorMsg.style.display === 'block') {
        errorMsg.textContent = lang === 'es' ? '¬øTemporizadores incorrectos? Comprueba la hora del sistema.' : 'Wrong timers? Check system time.';
      }
    });

    const themeSwitch = document.getElementById('themeSwitch');
    themeSwitch.addEventListener('change', () => {
      document.body.classList.toggle('light-theme', themeSwitch.checked);
      localStorage.setItem('lol-tracker-theme', themeSwitch.checked ? 'light' : 'dark');
    });

    soundSwitch.addEventListener('change', () => {});

    // ====================== ACTUALIZAR TEXTOS ======================
    function updateTexts() {
      const trans = translations[lang];

      updatePlayersBar();

      if (isHost) {
        const myShortId = document.getElementById('myShortId');
        if (myShortId) myShortId.value = shortId;

        const hostStatus = document.getElementById('hostStatus');
        if (hostStatus) {
          hostStatus.innerHTML = `
            <span class="status success">‚úÖ ${trans.host}</span>
            <span class="user-nick">${userNickname}</span>
          `;
        }

        const copyBtn = document.querySelector('#syncPanel button');
        if (copyBtn) copyBtn.textContent = trans.copy;
      } else {
        const pasteBtn = document.getElementById('pasteBtn');
        const joinBtn = document.querySelector('#syncPanel button[onclick="connectToHost()"]');
        if (pasteBtn) pasteBtn.textContent = trans.paste;
        if (joinBtn) joinBtn.textContent = trans.join;
      }

      document.getElementById('tutorialBox').innerHTML = `
        <div><strong>${trans.tutorialTitle}</strong></div>
        <div><span class="key-hint">1-5</span> ${trans.keyStart}</div>
        <div><span class="key-hint">Alt+1</span> ${trans.keyAlt}</div>
        <div><span class="key-hint">Shift+1</span> ${trans.keyShift}</div>
        <div><span class="key-hint">üñ±Ô∏è</span> ${trans.keyClick}</div>
        <div><span class="key-hint">√ó</span> ${trans.keyReset}</div>
        <div style="font-size:0.7rem; margin-top:8px; color:#aaa;">
          üë§ <strong>${userNickname}</strong> (${userRole === 'host' ? (lang === 'es' ? 'Anfitri√≥n' : 'Host') : (lang === 'es' ? 'Invitado' : 'Guest')})
        </div>
      `;

      document.querySelectorAll('.role-name').forEach((el, i) => {
        const role = ['Top', 'Jungle', 'Middle', 'Bottom', 'Support'][i];
        el.textContent = lang === 'es' ? {
          'Top': 'Superior',
          'Jungle': 'Jungla',
          'Middle': 'Medio',
          'Bottom': 'Inferior',
          'Support': 'Soporte'
        }[role] : role;
      });

      document.querySelectorAll('.reset-message').forEach(el => {
        el.textContent = trans.reset;
      });
    }

    // ====================== CONFIGURAR PANEL DE SINCRONIZACI√ìN ======================
    function setupSyncPanel() {
      const panel = document.getElementById('syncPanel');
      const playersBar = document.getElementById('players-bar');
      const trans = translations[lang];

      if (isSoloMode) {
        panel.style.display = 'none';
        playersBar.style.display = 'none';
        return;
      }

      if (isHost) {
        let championImg = '';
        if (userChampion) {
          const fileName = getChampionFileName(userChampion);
          championImg = `<img src="./Champions_assets/${fileName}.png" style="width: 20px; height: 20px; border-radius: 3px; margin-right: 6px; vertical-align: middle;" onerror="this.style.display='none'">`;
        }
        
        panel.innerHTML = `
          <h3 style="display: flex; justify-content: space-between; align-items: center;">
            <span>üîë ${trans.hostId}</span>
            <span id="playerCount" style="font-size: 0.8rem; color: #aaa; display: none;"></span>
          </h3>
          <div class="input-group">
            <input type="text" id="myShortId" readonly value="${trans.generating}" style="font-size: 1rem; text-align: center;">
            <button onclick="copyId()">${trans.copy}</button>
          </div>
          <div class="status" id="hostStatus">
            <span>üü¢ ${trans.waiting}</span>
            <span class="user-nick">${championImg}${userNickname}</span>
          </div>
        `;
      } else {
        panel.innerHTML = `
          <h3 style="display: flex; justify-content: space-between; align-items: center;">
            <span>üîë ${trans.hostId}</span>
            <span id="playerCount" style="font-size: 0.8rem; color: #aaa; display: none;"></span>
          </h3>
          <div class="input-group">
            <input type="text" id="hostIdInput" placeholder="${trans.hostId}" maxlength="6">
            <button id="pasteBtn" onclick="pasteId()">${trans.paste}</button>
            <button onclick="connectToHost()">${trans.join}</button>
          </div>
          <div class="status" id="clientStatus">
            <span></span>
            <span class="user-nick">${userNickname}</span>
          </div>
        `;
      }
      updatePlayersBar();
    }

    // ====================== PEGAR Y COPIAR ID ======================
    async function pasteId() {
      const trans = translations[lang];
      try {
        const text = await navigator.clipboard.readText();
        const clean = text.trim().toUpperCase();
        if (/^[A-HJ-NP-Z2-9]{6}$/.test(clean)) {
          document.getElementById('hostIdInput').value = clean;
        } else {
          document.getElementById('clientStatus').innerHTML = `
            <span class="error">‚ùå ${trans.invalidId}</span>
            <span class="user-nick">${userNickname}</span>
          `;
        }
      } catch (err) {
        document.getElementById('clientStatus').innerHTML = `
          <span class="error">‚ùå ${trans.error}: clipboard</span>
          <span class="user-nick">${userNickname}</span>
        `;
      }
    }

    function copyId() {
      const trans = translations[lang];
      const input = document.getElementById('myShortId');
      input.select();
      document.execCommand('copy');
      input.value = trans.copy;
      setTimeout(() => { input.value = shortId; }, 1000);
    }
    


    // ====================== INICIALIZAR PEER ======================
    function initPeer() {
      if (peer) {
        peer.destroy();
        connections = [];
        myConnection = null;
        clearInterval(pingInterval);
        clearInterval(cleanupInterval);
      }

      const config = {
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' },
            { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
            { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' }
          ]
        }
      };

      const peerId = isHost ? `${shortId}_host` : `${shortId}_client_${Math.random().toString(36).substr(2, 6)}`;
      peer = new Peer(peerId, config);

      peer.on('open', (id) => {
        myPeerId = id;
        
        if (isHost) {
          // No limpiar si ya hay conexiones P2P
          if (connections.length === 0) {
            connectedPlayers.clear();
          }
        }
        connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });

        if (isHost) {
          const myShortIdInput = document.getElementById('myShortId');
          myShortIdInput.value = shortId;
          
          // Mostrar mensaje temporal si hay conexiones existentes
          if (connections.length > 0) {
            document.getElementById('hostStatus').innerHTML = `
              <span class="status success">‚úÖ Reconectado jugadores</span>
              <span class="user-nick">${sanitizeNickname(userNickname)}</span>
            `;
            setTimeout(() => {
              document.getElementById('hostStatus').innerHTML = `
                <span class="status success">‚úÖ ${translations[lang].host}</span>
                <span class="user-nick">${sanitizeNickname(userNickname)}</span>
              `;
            }, 10000);
            
            // Notificar a invitados que se reconectaron
            connections.forEach(conn => {
              if (conn.open) {
                conn.send({ a: 'hostInfo', nick: sanitizeNickname(userNickname), from: myPeerId });
              }
            });
          } else {
            document.getElementById('hostStatus').innerHTML = `
              <span class="status success">‚úÖ ${translations[lang].host}</span>
              <span class="user-nick">${sanitizeNickname(userNickname)}</span>
            `;
          }
          

          
          startHostMonitoring();
          broadcastPlayerList();
        }
      });

      peer.on('error', (err) => {
        const trans = translations[lang];
        if (err.type === 'unavailable-id') {
          document.getElementById('hostStatus').innerHTML = `
            <span class="error">‚ùå ${trans.idInUse}</span>
            <span class="user-nick">${userNickname}</span>
          `;
        } else {
          document.getElementById('hostStatus').innerHTML = `
            <span class="error">‚ùå ${trans.error}: ${err.type}</span>
            <span class="user-nick">${userNickname}</span>
          `;
        }
      });

      peer.on('connection', (conn) => {
        if (isHost) {
          if (connections.length >= 7) {
            conn.close();
            return;
          }
          setupConnection(conn);
        } else {
          // Invitados solo aceptan conexiones P2P para sincronizaci√≥n de temporizadores
          peerConnections.set(conn.peer, conn);
          conn.on('data', (peerData) => {
            // Solo manejar eventos de temporizadores, no informaci√≥n de jugadores
            handleSync(peerData);
          });
          
          conn.on('close', () => {
            peerConnections.delete(conn.peer);
          });
        }
      });
    }

    // ====================== CONFIGURAR CONEXI√ìN ======================
    function setupConnection(conn) {
      let connectionTimeout = setTimeout(() => {
        if (!conn.open) conn.close();
      }, 10000);

      conn.on('open', () => {
        clearTimeout(connectionTimeout);
        connections.push(conn);
        
        conn.on('data', (data) => {
          if (!validateEventData(data)) return;
          
          if (data.a === 'playerInfo') {
            // 2.1. Recibir informaci√≥n del invitado
            const sanitizedNick = sanitizeNickname(data.nick);
            
            // 2.2. Actualizar lista de jugadores
            connectedPlayers.set(data.from, { 
              nick: sanitizedNick, 
              champion: data.champion, 
              color: data.color, 
              lastPong: Date.now() 
            });
            
            // Trackear orden de entrada
            if (!joinOrder.includes(data.from)) {
              joinOrder.push(data.from);
            }
            
            const guestPlayers = Array.from(connectedPlayers.keys()).filter(id => !connectedPlayers.get(id).isSelf);
            
            // 2.4. Asignar host secundario (primer invitado)
            if (guestPlayers.length === 1) {
              secondaryHostId = data.from;
              secondaryHostBackupId = generateShortId();
            }
            
            updatePlayersBar();
            
            // PASO 3: Enviar informaci√≥n actualizada
            const playersList = Array.from(connectedPlayers.entries())
              .map(([key, value]) => [key, { nick: value.nick, champion: value.champion, color: value.color }]);
            playersList.unshift([myPeerId, { nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor }]);
            
            // 4.4. Enviar A TODOS LOS INVITADOS la informaci√≥n actualizada
            const updateData = {
              a: 'connectionSuccess',
              playersList: playersList,
              hostBackupId: myBackupId,
              secondaryHostId: secondaryHostId,
              secondaryHostBackupId: secondaryHostBackupId
            };
            
            // Enviar a todos los invitados conectados
            connections.forEach(connection => {
              if (connection.open) {
                const personalizedData = {
                  ...updateData,
                  youAreSecondaryHost: (connection.peer === secondaryHostId),
                  yourBackupId: (connection.peer === secondaryHostId) ? secondaryHostBackupId : null
                };
                connection.send(personalizedData);
              }
            });
            
            // PASO 4: Establecer conexiones P2P para temporizadores
            const otherPlayers = Array.from(connectedPlayers.keys()).filter(id => id !== data.from && id !== myPeerId);
            if (otherPlayers.length > 0) {
              conn.send({ a: 'peerList', peers: otherPlayers });
            }
            
            sendFullState(conn);
            
            broadcastPlayerList();
            
            // Broadcast new player info to all existing connections
            connections.forEach(otherConn => {
              if (otherConn !== conn && otherConn.open) {
                try {
                  otherConn.send({ a: 'playerJoined', playerId: data.from, nick: sanitizedNick, champion: data.champion, color: data.color });
                  // Send existing players info to new connection
                  const existingPlayer = connectedPlayers.get(otherConn.peer);
                  if (existingPlayer) {
                    conn.send({ a: 'playerJoined', playerId: otherConn.peer, nick: existingPlayer.nick, champion: existingPlayer.champion, color: existingPlayer.color });
                  }
                } catch (e) {}
              }
            });
            
            // Send host info to new player
            conn.send({ a: 'playerJoined', playerId: myPeerId, nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor });
          } else if (data.a === 'hostInfo') {
            hostNickname = sanitizeNickname(data.nick);
          } else if (data.a === 'heartbeat') {
            // Recibir heartbeat de invitado
            if (data.nick && data.from) {
              const player = connectedPlayers.get(data.from);
              if (player) {
                player.nick = sanitizeNickname(data.nick);
                player.lastPong = Date.now();
              }
            }
            conn.send({ a: 'heartbeatAck', from: myPeerId });
          } else if (data.a === 'heartbeatAck') {
            // Host recibe confirmaci√≥n de heartbeat enviado
            const player = connectedPlayers.get(data.from);
            if (player) player.lastPong = Date.now();
            pendingPings.delete(data.from);
          } else if (data.a === 'secondaryHostBackupId') {
            // Recibir ID de respaldo del host secundario y compartirla
            secondaryHostBackupId = data.id;
            
            // Enviar a todos los jugadores conectados
            sendEvent({
              a: 'secondaryHostIdUpdate',
              secondaryHostId: data.from,
              secondaryHostBackupId: data.id
            });
          } else if (data.a === 'newHost') {
            hostNickname = sanitizeNickname(data.nick);
            updatePlayersBar();
          } else if (data.a === 'requestBackupId') {
            // Enviar mi ID de respaldo cuando el host la solicite
            conn.send({ a: 'secondaryHostBackupId', id: myBackupId, from: myPeerId });
          } else {
            // RETRANSMITIR EVENTOS DE JUEGO A OTROS CLIENTES
            if (['start', 'reset', 'adjust', 'startSecondary', 'resetSecondary', 'changeSpell', 'startGame', 'resetAll', 'unleashedTeleport', 'secondaryHostDesignated', 'secondaryHostIdUpdate'].includes(data.a)) {
              // Retransmitir a todos los otros clientes conectados
              connections.forEach(otherConn => {
                if (otherConn !== conn && otherConn.open) {
                  try {
                    otherConn.send(data);
                  } catch (e) {}
                }
              });
            }
          }
          handleSync(data);
        });

        conn.on('close', () => {
          const disconnectedPeerId = conn.peer;
          
          // 5.2. Actualizar lista de jugadores
          connectedPlayers.delete(disconnectedPeerId);
          connections = connections.filter(c => c.peer !== disconnectedPeerId);
          pendingPings.delete(disconnectedPeerId);
          
          // Remover del orden de entrada
          joinOrder = joinOrder.filter(id => id !== disconnectedPeerId);
          
          // 5.1. Comprobar si quien se desconect√≥ es el host secundario
          if (disconnectedPeerId === secondaryHostId) {
            // 5.1.1. Borrar informaci√≥n de backupID y secondaryHost
            secondaryHostId = null;
            secondaryHostBackupId = null;
            
            // 5.1.2. Asignar nuevo host secundario (siguiente en orden de entrada)
            const guestPlayers = joinOrder.filter(id => connectedPlayers.has(id));
            if (guestPlayers.length > 0) {
              secondaryHostId = guestPlayers[0];
              secondaryHostBackupId = generateShortId();
            }
          }
          
          // 5.3. Enviar nueva informaci√≥n a TODOS los invitados
          const playersList = Array.from(connectedPlayers.entries())
            .map(([key, value]) => [key, { nick: value.nick, champion: value.champion, color: value.color }]);
          playersList.unshift([myPeerId, { nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor }]);
          
          const updateData = {
            a: 'connectionSuccess',
            playersList: playersList,
            hostBackupId: myBackupId,
            secondaryHostId: secondaryHostId,
            secondaryHostBackupId: secondaryHostBackupId
          };
          
          // Broadcast a todos los invitados conectados
          connections.forEach(connection => {
            if (connection.open) {
              const personalizedData = {
                ...updateData,
                youAreSecondaryHost: (connection.peer === secondaryHostId),
                yourBackupId: (connection.peer === secondaryHostId) ? secondaryHostBackupId : null
              };
              connection.send(personalizedData);
            }
          });
          
          updatePlayersBar();
          
          // 5.4. Mantener mensaje "Eres el host"
          if (connectedPlayers.size === 1) { // Solo queda el host
            showToast(lang === 'es' ? 'üëë Eres el host.' : 'üëë You are the host.', 'info', 2000);
          }
          
          updatePlayersBar();
          broadcastPlayerList();
        });
      });

      conn.on('error', () => {
        clearTimeout(connectionTimeout);
      });
    }

    // ====================== CONECTAR AL HOST ======================
    function connectToHost() {
      const trans = translations[lang];
      const hostIdInput = document.getElementById('hostIdInput');
      const hostShortId = hostIdInput.value.trim().toUpperCase();

      if (!/^[A-HJ-NP-Z2-9]{6}$/.test(hostShortId)) {
        document.getElementById('clientStatus').innerHTML = `
          <span class="error">‚ùå ${trans.invalidId}</span>
          <span class="user-nick">${sanitizeNickname(userNickname)}</span>
        `;
        return;
      }

      if (myConnection && (myConnection.open || myConnection._connecting)) {
        return;
      }

      document.getElementById('clientStatus').textContent = trans.connecting;

      // 1.1. Mostrar mensaje "Conectando"
      showToast(lang === 'es' ? 'üîÑ Conectando...' : 'üîÑ Connecting...', 'info', 0);
      
      const hostPeerId = `${hostShortId}_host`;
      myConnection = peer.connect(hostPeerId);

      let connectionTimeout = setTimeout(() => {
        if (myConnection && !myConnection.open) {
          myConnection.close();
          document.getElementById('clientStatus').innerHTML = `
            <span class="error">‚ùå Connection timeout</span>
            <span class="user-nick">${sanitizeNickname(userNickname)}</span>
          `;
        }
      }, 15000);

      myConnection.on('open', () => {
        clearTimeout(connectionTimeout);
        
        setTimeout(() => {
          // 2.1. Enviar informaci√≥n al host
          myConnection.send({ a: 'playerInfo', nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor, from: myPeerId });
        
        // Iniciar heartbeat
        heartbeatInterval = setInterval(() => {
          if (myConnection && myConnection.open) {
            myConnection.send({ a: 'heartbeat', from: myPeerId, nick: sanitizeNickname(userNickname) });
          }
        }, 3000);
        }, 50);
        
        myConnection.on('data', (data) => {
          if (!validateEventData(data)) return;
          
          if (data.a === 'heartbeat') {
            // Responder al heartbeat del HOST
            myConnection.send({ a: 'heartbeatAck', from: myPeerId });
          } else if (data.a === 'hostInfo') {
            hostNickname = sanitizeNickname(data.nick);
            hadHostConnection = true;
            // Update host info with champion
            const hostPlayer = connectedPlayers.get(data.from);
            if (hostPlayer) {
              hostPlayer.champion = data.champion;
            } else {
              connectedPlayers.set(data.from, { nick: hostNickname, champion: data.champion, color: data.color, lastPong: Date.now() });
            }
            const trans = translations[lang];
            document.getElementById('clientStatus').innerHTML = `
              <span>‚úÖ ${trans.connected} <strong>${escapeHtml(hostNickname)}</strong></span>
              <span class="user-nick">${sanitizeNickname(userNickname)}</span>
            `;
            updatePlayersBar();
          } else if (data.a === 'playerList') {
            const list = new Map(data.players);
            connectedPlayers.clear();
            connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
            list.forEach((value, key) => {
              if (key !== myPeerId) {
                connectedPlayers.set(key, { ...value, nick: sanitizeNickname(value.nick), champion: value.champion, color: value.color, lastPong: Date.now() });
              }
            });
            updatePlayersBar();
          } else if (data.a === 'backupId') {
            // Almacenar ID de respaldo del jugador
            playerBackupIds.set(data.from, data.id);
            
            // Si es el host secundario, guardar su ID de respaldo
            if (data.from === secondaryHostId) {
              secondaryHostBackupId = data.id;
              updatePlayersBar(); // Actualizar UI inmediatamente
            }
          } else if (data.a === 'secondaryHostInfo') {
            // Recibir informaci√≥n del host secundario
            secondaryHostId = data.secondaryHostId;
            
            // Guardar ID de respaldo del host secundario
            if (secondaryHostId === myPeerId) {
              secondaryHostBackupId = myBackupId;
            } else {
              // Si no soy el host secundario, buscar su ID en playerBackupIds
              secondaryHostBackupId = playerBackupIds.get(secondaryHostId);
            }
            
            updatePlayersBar(); // Actualizar UI inmediatamente
          } else if (data.a === 'secondaryHostBackupId') {
            // Solo recibir backup ID del host secundario
            if (data.from === secondaryHostId) {
              secondaryHostBackupId = data.id;
              updatePlayersBar();
            }
            
            // El host ya envi√≥ mi backup ID
          } else if (data.a === 'peerList') {
            // 3. Establecer conexiones P2P EXCLUSIVAMENTE para temporizadores
            data.peers.forEach(peerId => {
              if (!peerConnections.has(peerId)) {
                const peerConn = peer.connect(peerId);
                peerConn.on('open', () => {
                  peerConnections.set(peerId, peerConn);
                });
                
                peerConn.on('data', (peerData) => {
                  // Solo manejar eventos de temporizadores
                  handleSync(peerData);
                });
                
                peerConn.on('close', () => {
                  peerConnections.delete(peerId);
                });
              }
            });
          } else if (data.a === 'heartbeatAck') {
            // HOST confirm√≥ recepci√≥n de nuestro heartbeat - conexi√≥n viva
            if (hostLostTimeout) clearTimeout(hostLostTimeout);
            hostLostTimeout = setTimeout(() => {
              // Si no recibimos heartbeat del host en 9s, considerarlo perdido
              if (secondaryHostId === myPeerId) {
                isHost = true;
                shortId = myBackupId;
                hostNickname = sanitizeNickname(userNickname);
                initializeHost();
                setupSyncPanel();
                initPeer();
              } else {
                attemptReconnectionWithRetries();
              }
            }, 9000);
              if (secondaryHostId === myPeerId) {
                // Soy el host secundario - ascender inmediatamente
                isHost = true;
                shortId = myBackupId;
                hostNickname = sanitizeNickname(userNickname);
                setupSyncPanel();
                initPeer();
              } else {
                // Solo intentar reconectar con host secundario, NO ascender
                if (secondaryHostBackupId) {
                  connectToSecondaryHost();
                } else {
                  tryConnectToBackupHosts();
                }
              }
            }, 10000);
          } else if (data.a === 'fullState') {
            applyFullState(data.state);
          } else if (data.a === 'newHostAnnouncement') {
            hostNickname = sanitizeNickname(data.nick);
            const trans = translations[lang];
            document.getElementById('clientStatus').innerHTML = `
              <span>‚úÖ ${trans.connected} <strong>${escapeHtml(hostNickname)}</strong></span>
              <span class="user-nick">${sanitizeNickname(userNickname)}</span>
            `;
            updatePlayersBar();
          } else if (data.a === 'playerJoined') {
            // Update player info when someone new joins
            connectedPlayers.set(data.playerId, { nick: sanitizeNickname(data.nick), champion: data.champion, color: data.color, lastPong: Date.now() });
            updatePlayersBar();
            
            // Propagar informaci√≥n a conexiones P2P
            peerConnections.forEach(peerConn => {
              if (peerConn.open && peerConn.peer !== data.playerId) {
                try {
                  peerConn.send({ a: 'playerJoined', playerId: data.playerId, nick: sanitizeNickname(data.nick), champion: data.champion, color: data.color });
                } catch (e) {}
              }
            });
          } else if (data.a === 'becomeHost') {
            isHost = true;
            hostNickname = sanitizeNickname(userNickname);
            setupSyncPanel();
            initPeer();
            updatePlayersBar();
          }
          handleSync(data);
        });
      });

      myConnection.on('close', () => {
        clearTimeout(connectionTimeout);
        if (heartbeatInterval) clearInterval(heartbeatInterval);
        
        // 6. Cuando pierde conexi√≥n con el host
        if (secondaryHostId === myPeerId) {
          // 6.1.1. Soy host secundario - convertirme en host
          isHost = true;
          shortId = myBackupId;
          hostNickname = sanitizeNickname(userNickname);
          
          // 6.1.2. Ejecutar procedimientos de host desde punto 1
          initializeHost();
          setupSyncPanel();
          initPeer();
        } else {
          // 6.2. No soy host secundario - intentar reconectar
          attemptReconnectionWithRetries();
        }
          setTimeout(() => {
            isHost = true;
            shortId = secondaryHostBackupId; // Usar la ID asignada por el host
            hostNickname = sanitizeNickname(userNickname);
            
            // Limpiar completamente el estado como host original
            if (heartbeatInterval) clearInterval(heartbeatInterval);
            if (hostLostTimeout) clearTimeout(hostLostTimeout);
            if (pingInterval) clearInterval(pingInterval);
            if (cleanupInterval) clearInterval(cleanupInterval);
            
            connections = [];
            connectedPlayers.clear();
            peerConnections.clear();
            pendingPings.clear();
            myPeerId = null; // Limpiar para que se actualice con la nueva ID de host
            
            // Limpiar informaci√≥n de host secundario al convertirse en host principal
            secondaryHostId = null;
            secondaryHostBackupId = null;
            
            setupSyncPanel();
            initPeer();
          }, 1000);
        } else {
          // Solo intentar reconectar, NO ascender (solo el host secundario designado puede ascender)
          
          // Mostrar mensaje de reconexi√≥n y conectar al host secundario
          const clientStatus = document.getElementById('clientStatus');
          if (clientStatus && secondaryHostBackupId) {
            clientStatus.innerHTML = `
              <span style="color: #ffeb3b;">üîÑ Reconectando con ${secondaryHostBackupId}</span>
              <span class="user-nick">${sanitizeNickname(userNickname)}</span>
            `;
          }
          
          setTimeout(() => {
            if (secondaryHostBackupId) {
              // Usar la ID almacenada del host secundario
              const testConnection = peer.connect(`${secondaryHostBackupId}_host`);
              
              const timeout = setTimeout(() => {
                testConnection.close();
                tryConnectToBackupHosts();
              }, 8000);
              
              testConnection.on('open', () => {
                clearTimeout(timeout);
                myConnection = testConnection;
                myConnection.send({ a: 'hello', nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor, from: myPeerId });
                
                heartbeatInterval = setInterval(() => {
                  if (myConnection && myConnection.open) {
                    myConnection.send({ a: 'heartbeat', from: myPeerId, nick: sanitizeNickname(userNickname) });
                  }
                }, 3000);
                
                myConnection.on('data', (data) => {
                  if (!validateEventData(data)) return;
                  
                  if (data.a === 'hostInfo') {
                    hostNickname = sanitizeNickname(data.nick);
                    document.getElementById('clientStatus').innerHTML = `
                      <span>‚úÖ Conectado con <strong>${escapeHtml(hostNickname)}</strong></span>
                      <span class="user-nick">${sanitizeNickname(userNickname)}</span>
                    `;
                    updatePlayersBar();
                  } else if (data.a === 'playerList') {
                    const list = new Map(data.players);
                    connectedPlayers.clear();
                    connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
                    list.forEach((value, key) => {
                      if (key !== myPeerId) {
                        connectedPlayers.set(key, { ...value, nick: sanitizeNickname(value.nick), lastPong: Date.now() });
                      }
                    });
                    updatePlayersBar();
                  } else if (data.a === 'peerList') {
                    data.peers.forEach(peerId => {
                      if (!peerConnections.has(peerId)) {
                        const peerConn = peer.connect(peerId);
                        peerConn.on('open', () => {
                          peerConnections.set(peerId, peerConn);
                          peerConn.send({ a: 'hello', from: myPeerId, nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor });
                          
                          peerConn.on('data', (peerData) => {
                            if (peerData.a === 'hello') {
                              connectedPlayers.set(peerData.from, { nick: sanitizeNickname(peerData.nick), champion: peerData.champion, color: peerData.color, lastPong: Date.now() });
                              updatePlayersBar();
                            } else {
                              handleSync(peerData);
                            }
                          });
                          
                          peerConn.on('close', () => {
                            peerConnections.delete(peerId);
                            connectedPlayers.delete(peerId);
                            updatePlayersBar();
                          });
                        });
                      }
                    });
                  } else if (data.a === 'requestNick') {
                    // Responder con mi nick cuando el host lo solicite
                    if (myConnection && myConnection.open) {
                      myConnection.send({ a: 'hello', nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor, from: myPeerId });
                    }
                  } else if (data.a === 'heartbeat') {
                    if (myConnection && myConnection.open) {
                      myConnection.send({ a: 'heartbeatAck', from: myPeerId });
                    }
                  } else if (data.a === 'fullState') {
                    applyFullState(data.state);
                  }
                  
                  handleSync(data);
                });
                
                myConnection.on('close', () => {
                  if (heartbeatInterval) clearInterval(heartbeatInterval);
                  myConnection = null;
                });
              });
              
              testConnection.on('error', () => {
                clearTimeout(timeout);
                tryConnectToBackupHosts();
              });
            } else {
              tryConnectToBackupHosts();
            }
          }, 3000);
        }
        
        myConnection = null;
      });

      myConnection.on('error', (err) => {
        clearTimeout(connectionTimeout);
        
        // 1.2. Mensaje de error para ID incorrecta
        showToast(lang === 'es' ? '‚ùå ID incorrecta o host no disponible' : '‚ùå Incorrect ID or host unavailable', 'error', 3000);
        
        document.getElementById('clientStatus').innerHTML = `
          <span class="error">‚ùå ${trans.error}: ${err.type}</span>
          <span class="user-nick">${sanitizeNickname(userNickname)}</span>
        `;
        myConnection = null;
        
        document.getElementById('joinBtn').disabled = false;
        document.getElementById('joinBtn').textContent = lang === 'es' ? 'Unirse' : 'Join';
      });
    }

    // ====================== MONITOREO DEL HOST ======================
    function startHostMonitoring() {
      // HOST: Heartbeat bidireccional cada 3s (consistente con invitados)
      pingInterval = setInterval(() => {
        const now = Date.now();
        connections.forEach(conn => {
          try {
            conn.send({ a: 'heartbeat', from: myPeerId, nick: sanitizeNickname(userNickname) });
            pendingPings.set(conn.peer, now);
          } catch (e) {}
        });
      }, 3000);

      cleanupInterval = setInterval(() => {
        const now = Date.now();
        let changed = false;
        connectedPlayers.forEach((player, peerId) => {
          if (player.isSelf) return;
          const conn = connections.find(c => c.peer === peerId);
          // Heartbeat cada 3s - si no responde en 12s, desconectado
          if (now - player.lastPong > 12000 && (!conn || !conn.open)) {
            connectedPlayers.delete(peerId);
            connections = connections.filter(c => c.peer !== peerId);
            pendingPings.delete(peerId);
            
            // Si el host secundario se desconecta, designar nuevo host secundario
            if (peerId === secondaryHostId) {
              const guestPlayers = Array.from(connectedPlayers.keys()).filter(id => !connectedPlayers.get(id).isSelf);
              if (guestPlayers.length > 0) {
                secondaryHostId = guestPlayers[0];
                secondaryHostBackupId = playerBackupIds.get(secondaryHostId) || null;
                sendEvent({
                  a: 'secondaryHostDesignated',
                  secondaryHostId: secondaryHostId,
                  joinOrder: guestPlayers
                });
                
                // Enviar informaci√≥n espec√≠fica al nuevo host secundario
                const newSecondaryConn = connections.find(c => c.peer === secondaryHostId);
                if (newSecondaryConn && newSecondaryConn.open) {
                  newSecondaryConn.send({ a: 'secondaryHostInfo', secondaryHostId, joinOrder: guestPlayers });
                  if (secondaryHostBackupId) {
                    newSecondaryConn.send({ a: 'secondaryHostIdUpdate', secondaryHostId, secondaryHostBackupId });
                  }
                  // Solicitar ID de respaldo del nuevo host secundario
                  newSecondaryConn.send({ a: 'requestBackupId', from: myPeerId });
                }
                
                // Forzar actualizaci√≥n de UI
                updatePlayersBar();
              } else {
                secondaryHostId = null;
                secondaryHostBackupId = null;
              }
            }
            
            changed = true;
          }
        });
        if (changed) {
          updatePlayersBar();
          broadcastPlayerList();
        }
      }, 3000);
    }

    // ====================== SINCRONIZACI√ìN ======================
    function sendEvent(data) {
      if (isSoloMode) return;
      
      const event = { ...data, from: myPeerId, nick: userNickname };
      if (isHost) {
        connections.forEach(conn => {
          if (conn.open) {
            try {
              conn.send(event);
            } catch (e) {}
          }
        });
      } else {
        // Enviar solo al host - el host se encarga de retransmitir
        if (myConnection && myConnection.open) {
          try {
            myConnection.send(event);
          } catch (e) {}
        }
      }
    }

    function sendFullState(conn) {
      const state = {
        primary: timerBoxes.map((box, i) => ({
          i,
          active: !!box.interval,
          seconds: parseInt(box.dataset.seconds) || DURATIONS.PRIMARY,
          completed: box.classList.contains('completed'),
          startTime: box.startTime || null
        })),
        secondary: staticTimers.map((el, i) => ({
          i,
          active: !!el.interval,
          seconds: parseInt(el.dataset.seconds) || parseInt(el.dataset.initialDuration),
          spell: spellSelects[i].value,
          completed: el.classList.contains('completed'),
          startTime: el.startTime || null
        })),
        gameTimer: {
          active: isGameStarted,
          seconds: gameTimerEl.classList.contains('active') ? parseTime(gameTimerEl.textContent) : DURATIONS.GAME,
          startTime: gameTimerEl.startTime || null
        }
      };
      conn.send({ a: 'fullState', state, from: myPeerId, nick: userNickname });
    }

    function parseTime(timeStr) {
      if (timeStr === 'Unleashed Teleport!') return 0;
      const [min, sec] = timeStr.split(':').map(Number);
      return min * 60 + sec;
    }

    function handleSync(data) {
      if (data.from === myPeerId) return;
      if (!validateEventData(data)) return;

      if (data.a === 'connectionSuccess') {
        // 2.2. Recibir lista de jugadores actualizada
        connectedPlayers.clear();
        connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
        
        data.playersList.forEach(([playerId, playerData]) => {
          if (playerId !== myPeerId) {
            connectedPlayers.set(playerId, { 
              nick: sanitizeNickname(playerData.nick), 
              champion: playerData.champion, 
              color: playerData.color, 
              lastPong: Date.now() 
            });
          }
        });
        
        // 2.3. Actualizar caja de jugadores UNA VEZ
        updatePlayersBar();
        
        // 2.4. Actualizar informaci√≥n interna backupID y host secundario
        hostBackupId = data.hostBackupId;
        
        if (data.youAreSecondaryHost) {
          secondaryHostId = myPeerId;
          secondaryHostBackupId = data.yourBackupId;
          myBackupId = data.yourBackupId;
        } else {
          if (data.secondaryHostId) {
            secondaryHostId = data.secondaryHostId;
            secondaryHostBackupId = data.secondaryHostBackupId;
          }
        }
        
        // 2.5. Mensaje "Conectado a [nombre del host]"
        const hostPlayer = data.playersList.find(([id]) => id === Object.keys(data.playersList[0] === myPeerId ? data.playersList[1] : data.playersList[0]));
        const hostName = data.playersList[0][1].nick; // El host siempre es el primero
        
        showToast(lang === 'es' ? 
          `‚úì Conectado a "${hostName}"` : 
          `‚úì Connected to "${hostName}"`, 'success', 3000);
        
        return;
      }
      
      // 4. Cuando entra otro invitado - 5. Cuando un invitado se desconecta
      // Ambos casos se manejan con connectionSuccess del host
      
      if (data.a === 'playerJoined') {
        connectedPlayers.set(data.playerId, { nick: sanitizeNickname(data.nick), champion: data.champion, color: data.color, lastPong: Date.now() });
        updatePlayersBar();
        return;
      }

      
      if (data.a === 'hostLost') {
        // Otro peer me notifica que perdi√≥ conexi√≥n con el host
        if (myConnection && myConnection.open) {
          // A√∫n tengo conexi√≥n, ignorar
          return;
        }
        
        // Solo el host secundario designado puede ascender
        if (secondaryHostId === myPeerId) {
          // Soy el host secundario, ascender inmediatamente
          setTimeout(() => {
            isHost = true;
            shortId = myBackupId;
            hostNickname = sanitizeNickname(userNickname);
            setupSyncPanel();
            initPeer();
          }, 1000);
        } else {
          // Intentar reconectar con host secundario
          setTimeout(() => {
            if (secondaryHostBackupId) {
              connectToSecondaryHost();
            } else {
              tryConnectToBackupHosts();
            }
          }, 2000);
        }
        return;
      }
      
      if (data.a === 'secondaryHostDesignated') {
        secondaryHostId = data.secondaryHostId;
        
        // Si soy el host secundario, enviar mi ID al host principal
        if (secondaryHostId === myPeerId) {
          secondaryHostBackupId = myBackupId;
          
          // Enviar mi ID de respaldo al host principal
          if (myConnection && myConnection.open) {
            myConnection.send({ a: 'secondaryHostBackupId', id: myBackupId, from: myPeerId });
          }
          
          // Monitorear conexi√≥n para ascender autom√°ticamente
          const checkConnection = setInterval(() => {
            if (!myConnection || !myConnection.open) {
              clearInterval(checkConnection);
              isHost = true;
              shortId = myBackupId;
              hostNickname = sanitizeNickname(userNickname);
              
              // Mantener conexiones P2P existentes y reconfigurarlas como host
              connections = Array.from(peerConnections.values()).filter(conn => conn.open);
              
              // Reconfigurar cada conexi√≥n para que tenga los listeners de host
              connections.forEach(conn => {
                // Remover listeners P2P existentes
                conn.removeAllListeners('data');
                
                // Configurar listener de host (id√©ntico a setupConnection)
                conn.on('data', (data) => {
                  if (!validateEventData(data)) return;
                  
                  if (data.a === 'playerInfo') {
                    const sanitizedNick = sanitizeNickname(data.nick);
                    const existingPlayer = connectedPlayers.get(data.from);
                    let hasChanged = false;
                    
                    if (!existingPlayer) {
                      connectedPlayers.set(data.from, { nick: sanitizedNick, lastPong: Date.now(), champion: data.champion, color: data.color });
                      hasChanged = true;
                    } else {
                      if (existingPlayer.nick !== sanitizedNick) {
                        existingPlayer.nick = sanitizedNick;
                        hasChanged = true;
                      }
                      if (existingPlayer.champion !== data.champion) {
                        existingPlayer.champion = data.champion;
                        hasChanged = true;
                      }
                      if (existingPlayer.color !== data.color) {
                        existingPlayer.color = data.color;
                        hasChanged = true;
                      }
                      existingPlayer.lastPong = Date.now();
                    }
                    
                    if (hasChanged) {
                      updatePlayersBar();
                      // Retransmitir a todos los otros invitados
                      connections.forEach(otherConn => {
                        if (otherConn !== conn && otherConn.open) {
                          try {
                            otherConn.send({ a: 'playerUpdate', playerId: data.from, nick: sanitizedNick, champion: data.champion, color: data.color });
                          } catch (e) {}
                        }
                      });
                    }
                  } else {
                    // Manejar otros eventos y retransmitir
                    if (['start', 'reset', 'adjust', 'startSecondary', 'resetSecondary', 'changeSpell', 'startGame', 'resetAll', 'unleashedTeleport', 'secondaryHostDesignated', 'secondaryHostIdUpdate'].includes(data.a)) {
                      connections.forEach(otherConn => {
                        if (otherConn !== conn && otherConn.open) {
                          try {
                            otherConn.send(data);
                          } catch (e) {}
                        }
                      });
                    }
                  }
                  handleSync(data);
                });
              });
              
              // Restaurar jugadores de conexiones P2P
              connectedPlayers.clear();
              connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
              peerConnections.forEach((conn, peerId) => {
                if (conn.open) {
                  connectedPlayers.set(peerId, { nick: 'Player', lastPong: Date.now() });
                }
              });
              
              // Regenerar orden y designar nuevo host secundario
              const guestPlayers = Array.from(peerConnections.keys()).filter(id => peerConnections.get(id).open);
              if (guestPlayers.length > 0) {
                secondaryHostId = guestPlayers[0];
                
                // Generar nueva backup ID si no existe
                if (!playerBackupIds.has(secondaryHostId)) {
                  playerBackupIds.set(secondaryHostId, generateShortId());
                }
                secondaryHostBackupId = playerBackupIds.get(secondaryHostId);
                
                // Notificar nuevo host secundario despu√©s de inicializar
                setTimeout(() => {
                  sendEvent({
                    a: 'secondaryHostDesignated',
                    secondaryHostId: secondaryHostId,
                    joinOrder: guestPlayers
                  });
                  
                  // Enviar backup ID al nuevo host secundario
                  const newSecondaryConn = connections.find(c => c.peer === secondaryHostId);
                  if (newSecondaryConn && newSecondaryConn.open) {
                    newSecondaryConn.send({ a: 'backupId', id: secondaryHostBackupId, from: myPeerId });
                    newSecondaryConn.send({ a: 'secondaryHostIdUpdate', secondaryHostId, secondaryHostBackupId });
                  }
                }, 2000);
              } else {
                secondaryHostId = null;
                secondaryHostBackupId = null;
              }
              
              setupSyncPanel();
              initPeer();
            }
          }, 1000);
        } else {
          // Si ya tengo la ID del host secundario, almacenarla
          const existingId = playerBackupIds.get(secondaryHostId);
          if (existingId) {
            secondaryHostBackupId = existingId;
          }
        }
        
        // Limpiar duplicados en connectedPlayers
        const uniquePlayers = new Map();
        connectedPlayers.forEach((player, id) => {
          if (!uniquePlayers.has(id)) {
            uniquePlayers.set(id, player);
          }
        });
        connectedPlayers.clear();
        uniquePlayers.forEach((player, id) => {
          connectedPlayers.set(id, player);
        });
        
        updatePlayersBar();
        return;
      }
      
      if (data.a === 'secondaryHostIdUpdate') {
        secondaryHostId = data.secondaryHostId;
        secondaryHostBackupId = data.secondaryHostBackupId;
        updatePlayersBar();
        return;
      }

      if (data.a === 'start') {
        const box = timerBoxes[data.i];
        if (box && !box.interval) {
          box.dataset.seconds = DURATIONS.PRIMARY;
          if (data.startTime) {
            const elapsed = Math.floor((new Date().getTime() - data.startTime) / 1000);
            const currentSeconds = Math.max(0, DURATIONS.PRIMARY - elapsed);
            box.dataset.seconds = currentSeconds;
            box.startTime = data.startTime;
          }
          startTimer(box, false);
        }
      }

      if (data.a === 'reset') {
        const box = timerBoxes[data.i];
        if (box) {
          box.startTime = null;
          resetTimer(box, false);
        }
      }

      if (data.a === 'adjust') {
        const box = timerBoxes[data.i];
        if (box && box.classList.contains('active')) {
          adjustTime(box, data.s, false);
        }
      }

      if (data.a === 'startSecondary') {
        const el = staticTimers[data.i];
        if (el && !el.interval) {
          const initialDuration = parseInt(el.dataset.initialDuration);
          el.dataset.seconds = initialDuration;
          if (data.startTime) {
            const elapsed = Math.floor((new Date().getTime() - data.startTime) / 1000);
            const currentSeconds = Math.max(0, initialDuration - elapsed);
            el.dataset.seconds = currentSeconds;
            el.startTime = data.startTime;
          }
          startStaticTimer(el);
          const row = el.parentElement;
          row.classList.add('secondary-active');
        }
      }

      if (data.a === 'resetSecondary') {
        const el = staticTimers[data.i];
        const select = spellSelects[data.i];
        if (el) {
          el.startTime = null;
          resetStaticTimer(el, select);
        }
      }

      if (data.a === 'changeSpell') {
        const el = staticTimers[data.i];
        const select = spellSelects[data.i];
        if (el && select) {
          select.value = data.spell;
          const d = spellData[data.spell];
          el.dataset.seconds = d.duration;
          el.dataset.initialDuration = d.duration;
          el.querySelector('span').textContent = formatTime(d.duration);
          el.style.backgroundImage = `url(${d.icon})`;
          updateStaticTimerStyle(el);
        }
      }

      if (data.a === 'startGame') {
        if (!isGameStarted) {
          if (gameTimerInterval) clearInterval(gameTimerInterval);
          gameTimerInterval = null;
          let totalSeconds = DURATIONS.GAME;
          gameTimerEl.textContent = formatTime(totalSeconds);
          gameTimerEl.classList.add('active');

          gameTimerInterval = setInterval(() => {
            totalSeconds--;
            gameTimerEl.textContent = formatTime(totalSeconds);
            if (totalSeconds <= 0) {
              clearInterval(gameTimerInterval);
              gameTimerInterval = null;
              gameTimerEl.textContent = 'Unleashed Teleport!';
              updateTeleportDuration(240);
            }
          }, 1000);
          isGameStarted = true;
          mainActionBtn.textContent = 'Reset All';
        }
      }

      if (data.a === 'resetAll') {
        timerBoxes.forEach(box => box.startTime = null);
        staticTimers.forEach(el => el.startTime = null);
        resetAll(false);
      }

      if (data.a === 'unleashedTeleport') {
        updateTeleportDuration(240);
      }
    }

    function applyFullState(state) {
      // Aplicar temporizadores primarios
      state.primary.forEach(timerData => {
        const box = timerBoxes[timerData.i];
        if (!box) return;

        if (box.interval) {
          clearInterval(box.interval);
          box.interval = null;
        }

        box.classList.remove('active', 'completed');
        const row = box.parentElement;
        row.classList.remove('active');

        const timeSpan = box.querySelector('.time');
        timeSpan.textContent = formatTime(timerData.seconds);
        box.dataset.seconds = timerData.seconds;

        if (timerData.completed) {
          box.classList.add('completed');
        } else if (timerData.active) {
          startTimer(box, false);
        }
      });

      // Aplicar temporizadores secundarios
      state.secondary.forEach(secData => {
        const el = staticTimers[secData.i];
        const select = spellSelects[secData.i];
        if (!el || !select) return;

        if (el.interval) {
          clearInterval(el.interval);
          el.interval = null;
        }

        el.classList.remove('active', 'completed');
        const row = el.parentElement;
        row.classList.remove('secondary-active');

        const timeSpan = el.querySelector('span');
        select.value = secData.spell;
        const spellInfo = spellData[secData.spell];
        if (spellInfo) {
          el.style.backgroundImage = `url(${spellInfo.icon})`;
          el.dataset.initialDuration = spellInfo.duration;
        }

        if (secData.completed) {
          el.classList.add('completed');
          el.dataset.seconds = parseInt(el.dataset.initialDuration);
          timeSpan.textContent = formatTime(el.dataset.seconds);
        } else if (secData.active) {
          el.dataset.seconds = secData.seconds;
          if (secData.startTime) {
            el.startTime = secData.startTime;
          }
          timeSpan.textContent = formatTime(secData.seconds);
          startStaticTimer(el);
          row.classList.add('secondary-active');
        } else {
          el.dataset.seconds = secData.seconds;
          timeSpan.textContent = formatTime(secData.seconds);
        }
      });
    }

    // ====================== JUGADORES CONECTADOS ======================
    function updatePlayersBar() {
      const trans = translations[lang];
      const playerCountEl = document.getElementById('playerCount');
      const secondaryHostInfo = document.getElementById('secondary-host-info');
      
      // Mostrar info del host secundario
      if (secondaryHostId && secondaryHostBackupId) {
        const secondaryPlayer = connectedPlayers.get(secondaryHostId);
        const secondaryNick = secondaryPlayer ? secondaryPlayer.nick : (secondaryHostId === myPeerId ? sanitizeNickname(userNickname) : 'Player');
        secondaryHostInfo.textContent = `Secondary Host: ${secondaryNick} (ID: ${secondaryHostBackupId})`;
      } else {
        secondaryHostInfo.textContent = '';
      }
      
      if (connectedPlayers.size === 0) {
        if (!isHost && hadHostConnection) {
          document.getElementById('players-list').textContent = trans.playingSoloHostLost;
        } else {
          document.getElementById('players-list').textContent = trans.playingSolo;
        }
        if (playerCountEl) playerCountEl.style.display = 'none';
        return;
      }

      if (connectedPlayers.size === 1) {
        document.getElementById('players-list').textContent = trans.playingSolo;
        if (playerCountEl) playerCountEl.style.display = 'none';
        return;
      }
      
      if (playerCountEl) {
        playerCountEl.textContent = `${lang === 'es' ? 'Jugadores' : 'Players'}: ${connectedPlayers.size}/7`;
        playerCountEl.style.display = 'block';
      }

      const sorted = Array.from(connectedPlayers.entries())
        .sort(([keyA, a], [keyB, b]) => (a.isSelf ? -1 : b.isSelf ? 1 : 0));

      const list = sorted.map(([playerId, p]) => {
        let championImg = '';
        
        // Show champion image for any player who has one
        const championToShow = p.isSelf ? userChampion : p.champion;
        if (championToShow) {
          const fileName = getChampionFileName(championToShow);
          championImg = `<img src="./Champions_assets/${fileName}.png" style="width: 16px; height: 16px; border-radius: 2px; margin-right: 4px; vertical-align: middle;" onerror="this.style.display='none'">`;
        }
        
        // Apply user color with gradient support
        let userColorToShow = p.isSelf ? userColor : p.color;
        
        // Diana easter egg override - check for Diana names
        const isDianaName = p.nick === 'Diana, Scorn of the Moon' || p.nick === 'Diana, El desd√©n de la Luna';
        if (isDianaName) {
          userColorToShow = 'linear-gradient(45deg, #ffffff, #87ceeb)';
        }
        
        let colorStyle = '';
        if (userColorToShow) {
          if (userColorToShow.startsWith('linear-gradient')) {
            colorStyle = `background: ${userColorToShow}; -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; display: inline-block;`;
          } else {
            colorStyle = `color: ${userColorToShow};`;
          }
        }
        
        let name;
        if (p.isSelf) {
          if (userColorToShow && userColorToShow.startsWith('linear-gradient')) {
            name = `${championImg}<strong style="${colorStyle}">${escapeHtml(p.nick)}</strong>`;
          } else {
            name = `${championImg}<strong style="color:#4caf50; ${colorStyle}">${escapeHtml(p.nick)}</strong>`;
          }
        } else {
          name = `${championImg}<span style="${colorStyle}">${escapeHtml(p.nick)}</span>`;
        }
        
        if ((isHost && p.isSelf) || (!isHost && p.nick === hostNickname)) {
          name += ' üëë';
        }
        
        return name;
      });

      document.getElementById('players-list').innerHTML = list.join(', ');
    }

    function broadcastPlayerList() {
      if (!isHost) return;
      const list = Array.from(connectedPlayers.entries())
        .filter(([key, value]) => !value.isSelf)
        .map(([key, value]) => [key, { nick: value.nick, champion: value.champion, color: value.color }]);
      
      list.unshift([myPeerId, { nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor }]);

      connections.forEach(conn => {
        if (conn.open) {
          try {
            conn.send({ a: 'playerList', players: list });
          } catch (e) {}
        }
      });
    }

    // ====================== ATAJOS DE TECLADO ======================
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) return;
      
      // Bloquear atajos si estamos escribiendo en el campo de ID del host
      const hostIdInput = document.getElementById('hostIdInput');
      if (hostIdInput && document.activeElement === hostIdInput) return;

      let key = null;
      if (e.code === 'Digit1') key = '1';
      else if (e.code === 'Digit2') key = '2';
      else if (e.code === 'Digit3') key = '3';
      else if (e.code === 'Digit4') key = '4';
      else if (e.code === 'Digit5') key = '5';
      else return;

      const index = keyMap[key];
      const box = timerBoxes[index];
      if (!box) return;

      if (e.altKey) {
        e.preventDefault();
        if (box.classList.contains('active')) {
          showButtonsWithTimeout(box);
          // Animar bot√≥n -10
          const btn10 = box.querySelector('.time-shortcut[data-sec="-10"]');
          if (btn10) {
            btn10.style.transform = 'scale(0.9)';
            btn10.style.background = 'var(--accent-primary)';
            setTimeout(() => {
              btn10.style.transform = '';
              btn10.style.background = '';
            }, 150);
          }
        }
        adjustTime(box, -10, true);
      } else if (e.shiftKey) {
        e.preventDefault();
        if (box.classList.contains('active')) {
          showButtonsWithTimeout(box);
          // Animar bot√≥n -30
          const btn30 = box.querySelector('.time-shortcut[data-sec="-30"]');
          if (btn30) {
            btn30.style.transform = 'scale(0.9)';
            btn30.style.background = 'var(--accent-primary)';
            setTimeout(() => {
              btn30.style.transform = '';
              btn30.style.background = '';
            }, 150);
          }
        }
        adjustTime(box, -30, true);
      } else {
        e.preventDefault();
        box.click();
      }
    });

    // ====================== ACTUALIZAR DURACI√ìN DE TELEPORT ======================
    function updateTeleportDuration(newDuration) {
      if (newDuration === 240) {
        isTeleportUnleashed = true;
      }
      staticTimers.forEach((el, i) => {
        const select = spellSelects[i];
        if (select.value === 'teleport') {
          const timeSpan = el.querySelector('span');
          el.dataset.seconds = newDuration;
          el.dataset.initialDuration = newDuration;
          timeSpan.textContent = formatTime(newDuration);
        }
      });
    }

    // ====================== INICIO ======================
    document.addEventListener('DOMContentLoaded', () => {
      // Configuraci√≥n inicial
      document.getElementById('langSwitch').checked = lang === 'es';
      document.getElementById('themeSwitch').checked = themeToUse === 'light';
      
      // Activar modo Diana si viene en la URL
      if (dianaMode) {
        document.body.classList.add('diana-mode');
        const title = document.getElementById('appTitle');
        if (lang === 'es') {
          title.innerHTML = `<span style="filter: grayscale(1) brightness(2);">üåô</span> Una nueva luna se alza <span style="filter: grayscale(1) brightness(2);">üåô</span>`;
        } else {
          title.innerHTML = `<span style="filter: grayscale(1) brightness(2);">üåô</span> A new moon is rising <span style="filter: grayscale(1) brightness(2);">üåô</span>`;
        }
        
        // Cambiar favicon
        const favicon = document.querySelector('link[rel="icon"]');
        favicon.href = './images/Diana.png';
      }
      
      // Crear temporizadores
      console.log('DOM loaded, creating timers...');
      
      // ====================== CREACI√ìN DE TEMPORIZADORES ======================
      roles.forEach((role, i) => {
        const row = document.createElement('div');
        row.className = 'timer-row';

        const resetBtn = document.createElement('button');
        resetBtn.className = 'reset-btn';
        resetBtn.innerHTML = '√ó';
        resetBtn.title = translations[lang].reset;
        resetBtn.onclick = (e) => {
          e.stopPropagation();
          resetTimer(timerBoxes[i], true);
        };

        const roleIcon = document.createElement('div');
        roleIcon.className = 'role-icon';
        const img = document.createElement('img');
        img.src = icons[i];
        img.alt = role;
        img.title = role;
        img.onerror = function() { this.src = './images/Flash.png'; };
        roleIcon.appendChild(img);

        const box = document.createElement('div');
        box.className = 'timer-box';
        box.dataset.role = role;
        box.dataset.index = i;

        const message = document.createElement('div');
        message.className = 'reset-message';
        message.textContent = translations[lang].reset;
        box.appendChild(message);

        const notification = document.createElement('div');
        notification.className = 'time-notification';
        notification.textContent = '-10s';
        box.appendChild(notification);

        const feedback = document.createElement('div');
        feedback.className = 'feedback';
        feedback.textContent = '-10';
        box.appendChild(feedback);

        const roleName = document.createElement('span');
        roleName.className = 'role-name';
        roleName.textContent = lang === 'es' ? {
          'Top': 'Superior',
          'Jungle': 'Jungla',
          'Middle': 'Medio',
          'Bottom': 'Inferior',
          'Support': 'Soporte'
        }[role] : role;

        const controls = document.createElement('div');
        controls.style.display = 'flex';
        controls.style.alignItems = 'center';
        controls.style.gap = '6px';
        controls.innerHTML = `
          <button class="time-shortcut" data-sec="-10">-10</button>
          <button class="time-shortcut" data-sec="-30">-30</button>
          <span class="time">05:00</span>
        `;

        box.appendChild(roleName);
        box.appendChild(controls);

        // TEMPORIZADOR SECUNDARIO
        const staticTimer = document.createElement('div');
        staticTimer.className = 'static-timer';
        staticTimer.innerHTML = `<span>05:00</span>`;
        staticTimer.dataset.role = role;
        staticTimer.dataset.index = i;

        // Desplegable
        const select = document.createElement('select');
        select.className = 'spell-select';

        Object.keys(spellData).forEach(spell => {
          const option = document.createElement('option');
          option.value = spell;
          option.textContent = spell.charAt(0).toUpperCase() + spell.slice(1);
          select.appendChild(option);
        });

        const defaultSpell = defaultSpells[i];
        select.value = defaultSpell;
        const data = spellData[defaultSpell];
        staticTimer.dataset.seconds = data.duration;
        staticTimer.dataset.initialDuration = data.duration;
        staticTimer.querySelector('span').textContent = formatTime(data.duration);
        staticTimer.style.backgroundImage = `url(${data.icon})`;

        select.addEventListener('change', () => {
          const spell = select.value;
          const d = spellData[spell];
          staticTimer.dataset.seconds = d.duration;
          staticTimer.dataset.initialDuration = d.duration;
          staticTimer.querySelector('span').textContent = formatTime(d.duration);
          staticTimer.style.backgroundImage = `url(${d.icon})`;
          updateStaticTimerStyle(staticTimer);
          
          // Actualizar icono de rol si los desplegables est√°n visibles
          const arrow = document.getElementById('toggleArrow');
          if (arrow.textContent.trim() === '‚¨ÖÔ∏è') {
            const roleIcon = document.querySelectorAll('.role-icon')[i];
            const img = roleIcon.querySelector('img');
            img.src = d.icon;
          }
          
          sendEvent({
            a: 'changeSpell',
            i: i,
            spell: spell
          });
        });

        // Bot√≥n de reinicio secundario
        const resetBtnSecondary = document.createElement('button');
        resetBtnSecondary.className = 'reset-btn-secondary';
        resetBtnSecondary.innerHTML = '√ó';
        resetBtnSecondary.title = 'Reset Spell';
        resetBtnSecondary.onclick = (e) => {
          e.stopPropagation();
          resetStaticTimer(staticTimer, select);
          sendEvent({
            a: 'resetSecondary',
            i: i
          });
        };

        row.appendChild(resetBtn);
        row.appendChild(roleIcon);
        row.appendChild(box);
        row.appendChild(staticTimer);
        row.appendChild(resetBtnSecondary);
        row.appendChild(select);

        select.style.display = 'none';

        staticTimer.addEventListener('click', (e) => {
          if (staticTimer.classList.contains('active')) return;
          startStaticTimer(staticTimer);
          row.classList.add('secondary-active');
          sendEvent({
            a: 'startSecondary',
            i: i,
            s: parseInt(staticTimer.dataset.seconds),
            startTime: staticTimer.startTime
          });
        });

        timerBoxes[i] = box;
        staticTimers[i] = staticTimer;
        spellSelects[i] = select;

        box.onclick = (e) => {
          if (e.target === message || e.target.closest('.time-shortcut')) return;
          
          if (box.classList.contains('active')) {
            // Efecto de pulsaci√≥n en la caja del temporizador
            box.style.transform = 'scale(1.02)';
            setTimeout(() => {
              box.style.transform = '';
            }, 150);
            
            // Mostrar botones y reiniciar timeout
            showButtonsWithTimeout(box);
            return;
          }
          
          startTimer(box, true);
          // Mostrar botones al iniciar temporizador
          showButtonsWithTimeout(box);
        };
        
        // Mostrar botones al hacer hover solo si est√° activo
        box.addEventListener('mouseenter', () => {
          if (box.classList.contains('active')) {
            showButtonsWithTimeout(box);
          }
        });
        
        box.addEventListener('mouseleave', () => {
          // No hacer nada al salir del hover, el timeout se encarga
        });

        box.querySelectorAll('.time-shortcut').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const seconds = parseInt(e.target.dataset.sec);
            adjustTime(box, seconds, true);
          });
        });

        document.getElementById('timers').appendChild(row);
        console.log(`Timer ${i} (${role}) created and appended`);
      });
      console.log('All timers created successfully');
      
      gameTimerEl = document.getElementById('gameTimer');
      mainActionBtn = document.getElementById('mainActionBtn');

      mainActionBtn.addEventListener('click', () => {
        if (isGameStarted) {
          resetAll();
        } else {
          startGameTimer();
          mainActionBtn.textContent = 'Reset All';
        }
      });

      // Definir toggleTutorial antes de usarlo
      function toggleTutorial() {
        const box = document.getElementById('tutorialBox');
        const arrow = document.getElementById('tutorialArrow');
        
        if (box.classList.contains('show')) {
          box.classList.remove('show');
          arrow.textContent = '‚ñº';
        } else {
          box.classList.add('show');
          arrow.textContent = '‚ñ≤';
        }
      }
      
      document.getElementById('toggleSpellsBtn').addEventListener('click', toggleSpells);
      document.getElementById('tutorialToggle').addEventListener('click', toggleTutorial);

      setupSyncPanel();
      if (!isSoloMode) {
        initPeer();
      }
      updateTexts();
    });

    function promoteToHost() {
      if (isHost) return;
      
      isHost = true;
      shortId = generateShortId();
      hostNickname = sanitizeNickname(userNickname);
      
      setupSyncPanel();
      initPeer();
      
      setTimeout(() => {
        updatePlayersBar();
      }, 1000);
    }
    
    function connectToSecondaryHost() {
      // Conectar igual que al host original
      const hostIdInput = document.getElementById('hostIdInput');
      if (hostIdInput) {
        hostIdInput.value = secondaryHostBackupId;
      }
      connectToHost(); // Usar la funci√≥n original de conexi√≥n
    }
    
    function tryConnectToBackupHosts() {
      const backupIds = Array.from(playerBackupIds.values());
      let attemptIndex = 0;
      
      const tryNext = () => {
        if (attemptIndex >= backupIds.length) {
          // Si no se puede conectar a ning√∫n backup, convertirse en host
          isHost = true;
          shortId = myBackupId;
          hostNickname = sanitizeNickname(userNickname);
          
          // Mantener conexiones P2P existentes y reconfigurarlas como host
          connections = Array.from(peerConnections.values()).filter(conn => conn.open);
          
          // Reconfigurar cada conexi√≥n para que tenga los listeners de host
          connections.forEach(conn => {
            // Remover listeners P2P existentes
            conn.removeAllListeners('data');
            
            // Configurar listener de host (id√©ntico a setupConnection)
            conn.on('data', (data) => {
              if (!validateEventData(data)) return;
              
              if (data.a === 'playerInfo') {
                const sanitizedNick = sanitizeNickname(data.nick);
                const existingPlayer = connectedPlayers.get(data.from);
                let hasChanged = false;
                
                if (!existingPlayer) {
                  connectedPlayers.set(data.from, { nick: sanitizedNick, lastPong: Date.now(), champion: data.champion, color: data.color });
                  hasChanged = true;
                } else {
                  if (existingPlayer.nick !== sanitizedNick) {
                    existingPlayer.nick = sanitizedNick;
                    hasChanged = true;
                  }
                  if (existingPlayer.champion !== data.champion) {
                    existingPlayer.champion = data.champion;
                    hasChanged = true;
                  }
                  if (existingPlayer.color !== data.color) {
                    existingPlayer.color = data.color;
                    hasChanged = true;
                  }
                  existingPlayer.lastPong = Date.now();
                }
                
                if (hasChanged) {
                  updatePlayersBar();
                  // Retransmitir a todos los otros invitados
                  connections.forEach(otherConn => {
                    if (otherConn !== conn && otherConn.open) {
                      try {
                        otherConn.send({ a: 'playerUpdate', playerId: data.from, nick: sanitizedNick, champion: data.champion, color: data.color });
                      } catch (e) {}
                    }
                  });
                }
              } else {
                // Manejar otros eventos y retransmitir
                if (['start', 'reset', 'adjust', 'startSecondary', 'resetSecondary', 'changeSpell', 'startGame', 'resetAll', 'unleashedTeleport', 'secondaryHostDesignated', 'secondaryHostIdUpdate'].includes(data.a)) {
                  connections.forEach(otherConn => {
                    if (otherConn !== conn && otherConn.open) {
                      try {
                        otherConn.send(data);
                      } catch (e) {}
                    }
                  });
                }
              }
              handleSync(data);
            });
          });
          
          connectedPlayers.clear();
          connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
          
          // Designar host secundario si hay otros jugadores
          const remainingGuests = Array.from(peerConnections.keys()).filter(id => peerConnections.get(id).open);
          if (remainingGuests.length > 0) {
            secondaryHostId = remainingGuests[0];
            secondaryHostBackupId = playerBackupIds.get(secondaryHostId) || generateShortId();
            
            sendEvent({
              a: 'secondaryHostDesignated',
              secondaryHostId: secondaryHostId,
              joinOrder: remainingGuests
            });
          }
          
          setupSyncPanel();
          initPeer();
          updatePlayersBar();
          return;
        }
        
        const backupId = backupIds[attemptIndex];
        const testConnection = peer.connect(`${backupId}_host`);
        
        const timeout = setTimeout(() => {
          testConnection.close();
          attemptIndex++;
          setTimeout(tryNext, 500);
        }, 3000);
        
        testConnection.on('open', () => {
          clearTimeout(timeout);
          myConnection = testConnection;
          myConnection.send({ a: 'hello', nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor, from: myPeerId });
          
          heartbeatInterval = setInterval(() => {
            if (myConnection && myConnection.open) {
              myConnection.send({ a: 'heartbeat', from: myPeerId });
            }
          }, 3000);
          
          myConnection.on('data', (data) => {
            if (!validateEventData(data)) return;
            
            if (data.a === 'hostInfo') {
              hostNickname = sanitizeNickname(data.nick);
              const trans = translations[lang];
              document.getElementById('clientStatus').innerHTML = `
                <span>‚úÖ ${trans.connected} <strong>${escapeHtml(hostNickname)}</strong></span>
                <span class="user-nick">${sanitizeNickname(userNickname)}</span>
              `;
              updatePlayersBar();
            } else if (data.a === 'playerList') {
              const list = new Map(data.players);
              connectedPlayers.clear();
              connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
              list.forEach((value, key) => {
                if (key !== myPeerId) {
                  connectedPlayers.set(key, { ...value, nick: sanitizeNickname(value.nick), lastPong: Date.now() });
                }
              });
              updatePlayersBar();
            } else if (data.a === 'peerList') {
              data.peers.forEach(peerId => {
                if (!peerConnections.has(peerId)) {
                  const peerConn = peer.connect(peerId);
                  peerConn.on('open', () => {
                    peerConnections.set(peerId, peerConn);
                    peerConn.send({ a: 'hello', from: myPeerId, nick: sanitizeNickname(userNickname), champion: userChampion, color: userColor });
                    
                    peerConn.on('data', (peerData) => {
                      if (peerData.a === 'hello') {
                        connectedPlayers.set(peerData.from, { nick: sanitizeNickname(peerData.nick), champion: peerData.champion, color: peerData.color, lastPong: Date.now() });
                        updatePlayersBar();
                      } else {
                        handleSync(peerData);
                      }
                    });
                    
                    peerConn.on('close', () => {
                      peerConnections.delete(peerId);
                      connectedPlayers.delete(peerId);
                      updatePlayersBar();
                    });
                  });
                }
              });
            } else if (data.a === 'heartbeat') {
              if (myConnection && myConnection.open) {
                myConnection.send({ a: 'heartbeatAck', from: myPeerId });
              }
            } else if (data.a === 'fullState') {
              applyFullState(data.state);
            }
            
            handleSync(data);
          });
          
          myConnection.on('close', () => {
            if (heartbeatInterval) clearInterval(heartbeatInterval);
            myConnection = null;
          });
        });
        
        testConnection.on('error', () => {
          clearTimeout(timeout);
          attemptIndex++;
          setTimeout(tryNext, 500);
        });
      };
      
      tryNext();
    }
    
    function connectToNewHost(newHostId) {
      connectedPlayers.clear();
      connectedPlayers.set(myPeerId, { nick: sanitizeNickname(userNickname), lastPong: Date.now(), isSelf: true });
      
      const clientStatus = document.getElementById('clientStatus');
      if (clientStatus) {
        clientStatus.innerHTML = `
          <span class="error">‚ùå Connection Lost. Playing solo.</span>
          <span class="user-nick">${sanitizeNickname(userNickname)}</span>
        `;
      }
      
      updatePlayersBar();
    }
    


    // ====================== FUNCI√ìN SHOWTOAST ======================
    function showToast(message, type = 'info', duration = 3000) {
      // Crear elemento toast si no existe
      let toast = document.getElementById('toast');
      if (!toast) {
        toast = document.createElement('div');
        toast.id = 'toast';
        toast.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 12px 16px;
          border-radius: 6px;
          color: white;
          font-size: 0.9rem;
          font-weight: 500;
          z-index: 10000;
          opacity: 0;
          transform: translateX(100%);
          transition: all 0.3s ease;
          max-width: 300px;
          word-wrap: break-word;
        `;
        document.body.appendChild(toast);
      }
      
      // Configurar estilo seg√∫n tipo
      const colors = {
        info: '#2196f3',
        success: '#4caf50',
        error: '#f44336',
        warning: '#ff9800'
      };
      
      toast.style.backgroundColor = colors[type] || colors.info;
      toast.textContent = message;
      
      // Mostrar toast
      setTimeout(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translateX(0)';
      }, 10);
      
      // Ocultar toast despu√©s de la duraci√≥n
      if (duration > 0) {
        setTimeout(() => {
          toast.style.opacity = '0';
          toast.style.transform = 'translateX(100%)';
        }, duration);
      }
    }
    
    // Exponer funciones globales
    window.updateTexts = updateTexts;
    window.copyId = copyId;
    window.pasteId = pasteId;
    window.connectToHost = connectToHost;
    window.showToast = showToast;
  </script>

  <!-- Temporizador de partida y bot√≥n combinado -->
  <div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-top: 16px;">
    <span class="game-timer" id="gameTimer">10:00</span>
    <button class="main-action-btn" id="mainActionBtn">Start Game</button>
  </div>

  <div class="version-footer">
    Lol Spell Tracker v0.6.4 - 9/9/25 - fix function scope issues
  </div>

  <div id="secondary-host-info" style="font-size: 0.7rem; color: #888; text-align: center; margin-top: 5px;"></div>

  <button class="tutorial-toggle" id="tutorialToggle">
    <span id="tutorialArrow">‚ñº</span>
    <span>Tutorial</span>
  </button>
  
  <div class="tutorial-box" id="tutorialBox">
    <!-- Din√°mico -->
  </div>
</body>
</html>